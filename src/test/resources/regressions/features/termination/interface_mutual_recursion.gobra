// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

package termination

type FactEven interface {
	requires n >= 0
	decreases n
	factEven(n int) int
}

type FactOdd interface {
	requires n >= 0
	decreases n
	factOdd(n int) int
}

type FactEvenImpl struct {}
	requires v >= 0
	decreases v
	func(x FactEvenImpl)factEven(v int) int {
		if v == 0 {
			return 0
		} else {
			var y FactOdd = FactOddImpl{}
			return v * y.factOdd(v - 1)
		}
	}

type FactOddImpl struct {}
	requires v >= 0
	decreases v
	func(y FactOddImpl)factOdd(v int) int {
		if v == 0 {
			return 0
		} else if v == 1 {
				return 1
		} else {
				var y FactEven = FactEvenImpl{}
				return v * y.factEven(v - 1)
		}
	}

type FactEvenImplNotTer struct {}
	requires v >= 0
	decreases v
	func(x FactEvenImplNotTer)factEven(v int) int {
		if v == 0 {
			return 0
		} else {
			var y FactOdd = FactOddImplNotTer{}

			//:: ExpectedOutput(method_termination_error)
			return v * y.factOdd(v)
			}
		}

type FactOddImplNotTer struct {}
	requires v >= 0
	decreases v
	func(y FactOddImplNotTer)factOdd(v int) int {
		if v == 0 {
			return 0
		} else if v == 1 {
				return 1
		} else {
				var y FactEven = FactEvenImplNotTer{}
				return v * y.factEven(v - 1)
		}
	}

type IsEven interface {
	requires n >= 0
	decreases n
	isEven(n int) bool
}

type IsOdd interface {
	requires n >= 0
	decreases n
	isOdd(n int) bool
}

type IsEvenImpl struct {}
	requires n >= 0
	decreases n
	func(y IsEvenImpl)isEven(n int) bool {
		if n == 0 {
			return true
		} else {
			var y IsOdd = IsOddImpl{}
			return y.isOdd(n - 1)
		}
	}

type IsOddImpl struct {}
	requires n >= 0
	decreases n
	func(y IsOddImpl)isOdd(n int) bool {
		if n == 0 {
			return true
		} else {
			var y IsEven = IsEvenImpl{}
			return y.isEven(n - 1)
		}
	}

type IsEvenImpl2 struct {}
	requires n >= 0
	decreases n
	func(y IsEvenImpl2)isEven(n int) bool {
		if n == 0 {
			return true
		} else {
			var y IsOdd = IsOddImpl2{}
			return y.isOdd(n - 1)
		}
	}

type IsOddImpl2 struct {}
	requires n >= 0
	decreases n
	func(y IsOddImpl2)isOdd(n int) bool {
		if n == 0 {
			return true
		} else {
			var y IsEven = IsEvenImpl{}
				
			//:: ExpectedOutput(method_termination_error)
			return y.isEven(n)
		}
	}
	
type Fun1 interface {
	decreases m, n
	fun1(m int, n bool) int
}

type Fun2 interface {
	decreases n
	fun2(n int) int
}

type Fun1Impl struct {}
	decreases m, n
	func(y Fun1Impl)fun1(m int, n bool) int {
		var temp1 int
		var temp2 int
		if n {
			temp1 = y.fun1(m, false)
		} else {
			temp1 = 1
		}
		if m > 0 {
			var y Fun2 = Fun2Impl{}
			temp2 = y.fun2(m - 1)
		} else {
			temp2 = 2
		}
		return temp1 + temp2
	}

type Fun2Impl struct {}
	decreases n
	func(y Fun2Impl)fun2(n int) int {
		if n > 0 {
			var y Fun1 = Fun1Impl{}
			return y.fun1(n-1, true)
		} else {
			return 3
		}
	}

type Fun1ImplNotTer struct {}
	decreases m, n
	func(y Fun1ImplNotTer)fun1(m int, n bool) int {
		var temp1 int
		var temp2 int
		if n {
			temp1 = y.fun1(m,false)
		} else {
			temp1 = 1
		}
		if m > 0 {
			var y Fun2 = Fun2ImplNotTer{}
			
			//:: ExpectedOutput(method_termination_error)
			temp2 = y.fun2(m)
		} else {
			temp2 = 2
		}
		return temp1 + temp2
	}

type Fun2ImplNotTer struct {}
	decreases n
	func(y Fun2ImplNotTer)fun2(n int) int {
		if n > 0 {
			var y Fun1 = Fun1ImplNotTer{}
			return y.fun1(n-1, true)
		} else {
			return 3
		}
	}

type Infinite1 interface {
	decreases _
	infinite1(n int) int
}

type Infinite2 interface {
	decreases _
	infinite2(n int) int
}

type Infinite1Impl struct {}
	decreases _
	func(y Infinite1Impl)infinite1(n int) int {
		var x Infinite2 = Infinite2Impl{}
		return x.infinite2(n)
	}

type Infinite2Impl struct {}
	decreases _
	func(y Infinite2Impl)infinite2(n int) int {
		var x Infinite1 = Infinite1Impl{}
		return x.infinite1(n)
	}

type TestConditional1 interface {
	decreases x if 1 <= x
	decreases _ if x <= -1
	testConditional1(x int) int
}

type TestConditional2 interface {
	decreases x if 1 <= x
	decreases _ if x <= -1
	testConditional2(x int) int
}

type TestConditional1Impl struct {}

decreases x if 1 <= x
decreases _ if x <= -1
func(y TestConditional1Impl)testConditional1(x int) int {
	var z TestConditional2 = TestConditional2Impl{}
	if x == 0 {
		return z.testConditional2(x)
	} else {
		if 1 < x {
			//:: ExpectedOutput(method_termination_error)
			return z.testConditional2(x)
		} else {
			if x < -1 {
				return z.testConditional2(x + 1)
			} else {
				return x
			}
		}
	}
}

type TestConditional2Impl struct {}
	decreases x if 1 <= x
	decreases _ if x <= -1
	func(y TestConditional2Impl)testConditional2(x int) int {
		var z TestConditional1 = TestConditional1Impl{}
		if x == 0 {
			return z.testConditional1(x)
		} else {
			if 1 < x {
				return z.testConditional1(x - 1)
			} else {
				if x < -1 {
					return z.testConditional1(x + 1)
				} else {
					return x
				}
			}
		}
	}

