// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

package pkg

pure func parent (i int) int {
  return (i - 1) / 2
}

pure func leftChild (i int) int {
  return 2 * i + 1
}

pure func rightChild (i int) int {
  return 2 * i + 2
}

ghost
requires forall i int :: 0 <= i && i < len(s) ==> acc(&s[i])
ensures len(s) == len(xs)
ensures forall i int :: 0 <= i && i < len(s) ==> s[i] == xs[i]
pure func toseq (s []int) (xs seq[int])

ghost
requires 0 <= a && a <= b && b <= len(xs)
pure func heap (xs seq[int], a int, b int) bool {
  return forall i int :: a <= parent(i) && i < b ==> xs[i] <= xs[parent(i)]
}

ghost
pure func descendant (p int, q int) bool {
  return p == q || (p <= q && descendant(p, parent(q)))
}

ghost
requires 0 <= p && p <= q && q < end && end <= len(xs)
requires heap(xs, p, end)
requires descendant(p, q)
ensures res && xs[q] <= xs[p]
pure func lemma_descendant_order (xs seq[int], p int, q int, end int) (res bool) {
  return (p < q ==> descendant(p, parent(q)) && lemma_descendant_order(xs, p, parent(q), end))
}

ghost
requires 0 <= n
ensures res && descendant(0, n)
pure func lemma_descendant_zero (n int) (res bool) {
  return (0 < n ==> lemma_descendant_zero(parent(n)))
}

ghost
requires 0 <= i && i < end && end <= len(xs)
requires heap(xs, 0, end)
ensures res && xs[i] <= xs[0]
pure func lemma_heap_top (xs seq[int], i int, end int) (res bool) {
  return (lemma_descendant_zero(i) && lemma_descendant_order(xs, 0, i, end))
}

ghost
requires 0 <= end && end <= len(xs)
requires heap(xs, 0, end)
ensures res && forall i int :: 0 <= i && i < end ==> xs[i] <= xs[0]
pure func lemma_heap_top_all (xs seq[int], end int) (res bool) {
  return (forall i int :: 0 <= i && i < end && lemma_heap_top(xs, i, end) ==> xs[i] <= xs[0])
}

ghost
requires 0 <= end && end <= len(s)
requires forall i int :: 0 <= i && i < len(s) ==> acc(&s[i])
requires heap(toseq(s), 0, end)
ensures res && forall i int :: 0 <= i && i < end ==> s[i] <= s[0]
pure func lemma_heap_top_slice (s []int, end int) (res bool) {
  return lemma_heap_top_all(toseq(s), end)
}

requires forall n int :: 0 <= n && n < len(s) ==> acc(&s[n])
ensures forall n int :: 0 <= n && n < len(s) ==> acc(&s[n])
ensures forall a, b int :: 0 <= a && a <= b && b < len(s) ==> s[a] <= s[b]
func heapsort (s []int) {
  heapify(s)
  
  end := len(s) - 1
  
  invariant -1 <= end && end < len(s)
  invariant 0 < len(s) ==> 0 <= end
  invariant forall n int :: 0 <= n && n < len(s) ==> acc(&s[n])
  invariant forall n int :: 0 <= parent(n) && n < end + 1 ==> s[n] <= s[parent(n)]
  invariant forall a, b int :: end < a && a <= b && b < len(s) ==> s[a] <= s[b]
  invariant end + 1 < len(s) ==> forall n int :: 0 <= n && n < end + 1 ==> s[n] <= s[end + 1]
  for (0 < end) {
    assert lemma_heap_top_slice(s, end + 1)
    tmp := s[end]
    s[end] = s[0]
    s[0] = tmp
    siftDown(s, 0, end, true)
    end = end - 1
  }
}

requires forall n int :: 0 <= n && n < len(s) ==> acc(&s[n])
ensures forall n int :: 0 <= n && n < len(s) ==> acc(&s[n])
ensures forall n int :: 0 <= parent(n) && n < len(s) ==> s[n] <= s[parent(n)]
func heapify (s []int) {
  start := parent(len(s) - 1)
  
  invariant -1 <= start && start <= parent(len(s) - 1)
  invariant forall n int :: 0 <= n && n < len(s) ==> acc(&s[n])
  invariant forall n int :: start + 1 <= parent(n) && n < len(s) ==> s[n] <= s[parent(n)]
  for (0 <= start) {
    siftDown(s, start, len(s) - 1, false)
    start := start - 1
  }
}

requires 0 <= start && start <= parent(end)
requires 0 <= end && end < len(s)
requires forall n int :: 0 <= n && n < len(s) ==> acc(&s[n])
requires forall n int :: start <= parent(n) && n < end && parent(n) != start ==> s[n] <= s[parent(n)]
requires forall n int :: start <= parent(start) && start == parent(n) && n < end ==> s[n] <= s[parent(start)]
requires preserve ==> forall i int :: 0 <= i && i < end ==> s[i] <= s[end]
ensures forall n int :: 0 <= n && n < len(s) ==> acc(&s[n])
ensures forall n int :: start <= parent(n) && n < end ==> s[n] <= s[parent(n)]
ensures forall n int :: end <= n && n < len(s) ==> s[n] == old(s[n])
ensures preserve ==> forall i int :: 0 <= i && i < end ==> s[i] <= s[end]
func siftDown (s []int, start int, end int, ghost preserve bool) {
  root := start
  
  invariant start <= root
  invariant forall n int :: 0 <= n && n < len(s) ==> acc(&s[n])
  invariant forall n int :: start <= parent(n) && n < end && parent(n) != root ==> s[n] <= s[parent(n)]
  invariant forall n int :: start <= parent(root) && root == parent(n) && n < end ==> s[n] <= s[parent(root)]
  invariant forall n int :: end <= n && n < len(s) ==> s[n] == old(s[n])
  invariant preserve ==> forall i int :: 0 <= i && i < end ==> s[i] <= s[end]
  for (leftChild(root) < end) {
    child := leftChild(root)
    
    if (child + 1 < end && s[child] < s[child + 1]) {
      child = child + 1
    }
    
    if (s[root] < s[child]) {
      tmp := s[root]
      s[root] = s[child]
      s[child] = tmp
      root = child
    } else {
      root = end
    }
  }
}
