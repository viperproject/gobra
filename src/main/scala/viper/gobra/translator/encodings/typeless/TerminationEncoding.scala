// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// Copyright (c) 2011-2020 ETH Zurich.

package viper.gobra.translator.encodings.typeless

import org.bitbucket.inkytonik.kiama.==>
import viper.gobra.ast.{internal => in}
import viper.gobra.translator.encodings.combinators.Encoding
import viper.gobra.translator.context.Context
import viper.gobra.translator.util.ViperWriter.CodeWriter
import viper.gobra.util.Violation.violation
import viper.silver.ast.Member
import viper.silver.plugin.standard.{predicateinstance, termination}
import viper.silver.{ast => vpr}

class TerminationEncoding extends Encoding {

  import viper.gobra.translator.util.ViperWriter.CodeLevel._

  override def assertion(ctx: Context): in.Assertion ==> CodeWriter[vpr.Exp] = {
    case measure: in.TerminationMeasure =>
      val (pos, info, errT) = measure.vprMeta

      measure match {
        /**
         * Tuple termination measures are translated differently, depending on whether they occur in the interface of
         * an interface method's signature, or not. This helps dealing with concrete types that implement an interface
         * type T with method 'm'. If the implementation of 'm' on a concrete type calls method `m` in a value with
         * static type T, this may lead to termination errors, even though the program is safe. As an example of such
         * a program, consider the following:
         *
         *  type T interface {
         *    requires 0 <= x
         *    decreases x
         *    func f(x int) int
         *  }
         *
         *  type Impl struct{}
         *
         *  requires 0 <= x
         *  decreases x
         *  func (i Impl) f(x int) int {
         *    if 0 < x {
         *      var t T = i
         *      t.f(x - 1)
         *    }
         *  }
         *
         * At the encoding level, this leads to two mutually recursive functions with measure 'x', and a verification
         * error in one of the calls. Introducing an extra item 'i1' and 'i2' in termination measures of the interface
         * method and on the concrete implementation, respectively, such that 'i2' < 'i1' avoids these errors when doing
         * so is safe. We could have opted for users to provide this measure, instead of generating it at the encoding
         * level, but this requires knowing how the interface encoding works.
         *
         * As an example, the snippet above would be translated to sth morally equivalent to the following:
         *
         *   method T_f(receiver, x)
         *     requires 0 <= x
         *     decreases ItfMethodMeasure(), x
         *   {
         *     // body generated by the CGEdgesTerminationTransform
         *     ...
         *   }
         *
         *   method Impl_f(receiver, x)
         *     requires 0 <= x
         *     decreases NonItfMethodMeasure(), x
         *   {
         *     // body of Impl.f
         *     ...
         *   }
         */
        case t: in.TupleTerminationMeasure =>
          for {
            c <- option(t.cond map ctx.expression)
            v <- sequence(t.tuple.map {
              case e: in.Expr => ctx.expression(e)
              case p: in.Access => predicateInstance(p)(ctx)
              case _ => violation("invalid tuple measure argument")
            })
            lastElem: vpr.Exp = measure match {
              case _: in.ItfMethodMeasure => itfMethodApp
              case _: in.NonItfMethodMeasure => nonItfMethodApp
            }
          } yield termination.DecreasesTuple(v :+ lastElem, c)(pos, info, errT)
        case m: in.WildcardMeasure =>
          for {
            c <- option(m.cond map ctx.expression)
          } yield termination.DecreasesWildcard(c)(pos, info, errT)
      }
  }

  def predicateInstance(x: in.Access)(ctx: Context): CodeWriter[predicateinstance.PredicateInstance] = {
    val (pos, info, errT) = x.vprMeta
    for {
      v <- ctx.assertion(x)
      pap = v.asInstanceOf[vpr.PredicateAccessPredicate]
    } yield predicateinstance.PredicateInstance(pap.loc.predicateName, pap.loc.args)(pos, info, errT)
  }

  /**
   * Generates the following domains for termination measures related to interface/non-interface methods:
   *
   *   domain TerminationDomain {
   *       function ItfMethodMeasure(): TerminationDomain
   *       function NonItfMethodMeasure(): TerminationDomain
   *   }
   */
  private val domainName = "TerminationDomain"
  private val itfMethod = vpr.DomainFunc(
    name = "ItfMethodMeasure",
    formalArgs = Seq.empty,
    typ = vpr.DomainType(domainName = domainName, partialTypVarsMap = Map.empty)(Seq.empty),
    interpretation = None
  )(vpr.NoPosition, vpr.NoInfo, domainName, vpr.NoTrafos)
  private val itfMethodApp = vpr.DomainFuncApp(func = itfMethod, args = Seq.empty, typVarMap = Map.empty)()
  private val nonItfMethod = vpr.DomainFunc(
    name = "NonItfMethodMeasure",
    formalArgs = Seq.empty,
    typ = vpr.DomainType(domainName = domainName, partialTypVarsMap = Map.empty)(Seq.empty),
    interpretation = None
  )(vpr.NoPosition, vpr.NoInfo, domainName, vpr.NoTrafos)
  private val nonItfMethodApp = vpr.DomainFuncApp(func = nonItfMethod, args = Seq.empty, typVarMap = Map.empty)()
  private val termDomain = vpr.Domain(
    name = domainName,
    functions = Seq(itfMethod, nonItfMethod),
    axioms = Seq.empty,
    typVars = Seq.empty,
    interpretations = None
  )(vpr.NoPosition, vpr.NoInfo, vpr.NoTrafos)

  /**
   * Generates the following domains that defines the well-founded order on termination measures related
   * to interface/non-interface methods:
   *
   * domain TerminationDomainWellFoundedOrder {
   *    axiom {
   *        decreasing(NonItfMethodMeasure(), ItfMethodMeasure())
   *    }
   *
   *    axiom {
   *        bounded(NonItfMethodMeasure())
   *    }
   *
   *    axiom {
   *        bounded(ItfMethodMeasure())
   *    }
   * }
   */
  private val wfOrderDomainName = "WellFoundedOrder"
  private val termDomainWFOrderName = domainName + "WellFoundedOrder"
  private val termDomainWFOrder = vpr.Domain(
    name = termDomainWFOrderName,
    functions = Seq.empty,
    axioms = Seq(
      // decreasing(nonItfMethod, itfMethod)
      vpr.AnonymousDomainAxiom(
        exp = vpr.DomainFuncApp(
          funcname = "decreasing",
          args = Seq(nonItfMethodApp, itfMethodApp),
          typVarMap = Map(vpr.TypeVar("T") -> vpr.DomainType(termDomain, Map.empty))
        )(vpr.NoPosition, vpr.NoInfo, typ = vpr.Bool, domainName = wfOrderDomainName, vpr.NoTrafos)
      )(domainName = termDomainWFOrderName),
      // bounded(nonItfMethod)
      vpr.AnonymousDomainAxiom(
        exp = vpr.DomainFuncApp(
          funcname = "bounded",
          args = Seq(nonItfMethodApp),
          typVarMap = Map(vpr.TypeVar("T") -> vpr.DomainType(termDomain, Map.empty))
        )(vpr.NoPosition, vpr.NoInfo, typ = vpr.Bool, domainName = wfOrderDomainName, vpr.NoTrafos)
      )(domainName = termDomainWFOrderName),
      // bounded(itfMethod)
      vpr.AnonymousDomainAxiom(
        exp = vpr.DomainFuncApp(
          funcname = "bounded",
          args = Seq(itfMethodApp),
          typVarMap = Map(vpr.TypeVar("T") -> vpr.DomainType(termDomain, Map.empty))
        )(vpr.NoPosition, vpr.NoInfo, typ = vpr.Bool, domainName = wfOrderDomainName, vpr.NoTrafos)
      )(domainName = termDomainWFOrderName)

    ),
    typVars = Seq.empty,
    interpretations = None
  )(vpr.NoPosition, vpr.NoInfo, vpr.NoTrafos)

  override def finalize(addMemberFn: Member => Unit): Unit = {
    addMemberFn(termDomain)
    addMemberFn(termDomainWFOrder)
  }
}
