// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

package bar

//---------------------------------------------------

type Pair struct {
  Left, Right, p int
}

pred (p *Pair) Mem() {
  acc(&p.p)
}

ensures acc(&result.Left) && acc(&result.Right) && result.Mem()
ensures result.Left == value.Left && result.Right == value.Right
construct &Pair() {
  fold result.Mem()
}

//get p field of Pair
requires p.Mem()
pure func (p *Pair) GetPairP() int {
  return unfolding p.Mem() in p.p
}

//private function with struct (private specification and proof)
requires acc(x) && x.Left == 2
ensures  acc(x) && x.Left == 2
private {
  requires acc(x) && x.Left == 2
  ensures  acc(x) && x.Left == 2 && x.p == 3
  proof {
    PairFunction(a, b, x)
  }
}
func PairFunction(a, b int, x *Pair) {
  x.p = x.Left + 1
}

//--------------------------------------------------

type pvt struct {
  x int
}

pred (p *pvt) Mem() {
  acc(&p.x)
}

ensures result.Mem()
construct &pvt() {
  fold result.Mem()
}

ensures p.Mem() && p.GetPvtX() == a
func GetPvt(a int) (p *pvt) {
  p := &pvt{x: a}
  fold p.Mem()
}

requires p.Mem()
pure func (p *pvt) GetPvtX() int {
  return unfolding p.Mem() in p.x
}

requires p.Mem()
ensures p.Mem()
ensures p.GetPvtX() == old(p.GetPvtX()) + a
private {
  requires acc(p)
  ensures acc(p)
  ensures p.x == old(p.x) + a
  proof {
    unfold p.Mem()
    PvtFunction(p, a)
    fold p.Mem()
  }
}
func PvtFunction(p *pvt, a int) {
  p.x = p.x + a
}

//--------------------------------------------------

func testPrivate()

func (p *Pair) testPairPrivate()

func (p *pvt) testPvtPrivate()


//---------------------------------------------------

const g int = 2
const G int = 42

//----------------------------------------------------

pred P(a int) {
  a == 0
}

requires P(a)
ensures P(a)
private {
  requires a == 0
  ensures a == 0
  proof {
    unfold P(a)
    FPred(a)
    fold P(a)
  }
}
func FPred(a int)

pred p(a int) {
  a == 0
}

requires P(a)
ensures P(a)
private {
  requires a == 0
  ensures a == 0
  proof {
    unfold P(a)
    FPred2(a)
    fold P(a)
  }
}
func FPred2(a int) 

pure func PF(a int) int {
  return a
}

pure func pf(a int) int {
  return a
}