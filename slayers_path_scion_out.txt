[info] welcome to sbt 1.4.4 (AdoptOpenJDK Java 15.0.2)
[info] loading settings for project gobra-build from plugins.sbt ...
[info] loading project definition from /Users/herzamos/Desktop/eth/fs25/practical-work/gobra/project
[info] loading settings for project gobra from build.sbt ...
[info] loading settings for project server from build.sbt ...
[info] loading settings for project silicon from build.sbt ...
[info] loading settings for project carbon from build.sbt ...
[info] loading settings for project silver from build.sbt ...
[info] loading settings for project silver from build.sbt ...
[info] set current project to Gobra (in build file:/Users/herzamos/Desktop/eth/fs25/practical-work/gobra/)
No changes detected in the antlr4 files. Skipping parser generation.
[info] running (fork) viper.gobra.GobraRunner -p ../VerifiedSCION/pkg/slayers/path/scion --norespectFunctionPrePermAmounts --backend SILICON --chop 1 -I ../VerifiedSCION ../VerifiedSCION/verification/dependencies --onlyFilesWithHeader -m github.com/scionproto/scion --assumeInjectivityOnInhale --checkConsistency --mceMode=od --experimentalFriendClauses --moreJoins off -g /tmp/ --printVpr
[info] Gobra 1.1-SNAPSHOT (7d79f434@(detached))
[info] (c) Copyright ETH Zurich 2012 - 2024
[info] Verifying package ../VerifiedSCION/pkg/slayers/path/scion - scion [16:42:13]
[info] Skipping panic
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  sl.Bytes(raw, 0, len(raw))
[info] ensures   len(res) == segLen - currHfIdx
[info] decreases segLen - currHfIdx
[info] pure func hopFields(
[info] 	raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	segLen int) (res seq[io.HF]) {
[info] 	return currHfIdx == segLen ? seq[io.HF]{} :
[info] 		let hf := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw)) in
[info] 		seq[io.HF]{hf} ++ hopFields(raw, offset, currHfIdx + 1, segLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  sl.Bytes(raw, 0, len(raw))
[info] ensures   len(res) == segLen - currHfIdx
[info] decreases segLen - currHfIdx
[info] pure func hopFields(
[info] 	raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	segLen int) (res seq[io.HF]) {
[info] 	return currHfIdx == segLen ? seq[io.HF]{} :
[info] 		let hf := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw)) in
[info] 		seq[io.HF]{hf} ++ hopFields(raw, offset, currHfIdx + 1, segLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  sl.Bytes(raw, 0, len(raw))
[info] ensures   len(res) == segLen - currHfIdx
[info] decreases segLen - currHfIdx
[info] pure func hopFields(
[info] 	raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	segLen int) (res seq[io.HF]) {
[info] 	return currHfIdx == segLen ? seq[io.HF]{} :
[info] 		let hf := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw)) in
[info] 		seq[io.HF]{hf} ++ hopFields(raw, offset, currHfIdx + 1, segLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  sl.Bytes(raw, 0, len(raw))
[info] ensures   len(res) == segLen - currHfIdx
[info] decreases segLen - currHfIdx
[info] pure func hopFields(
[info] 	raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	segLen int) (res seq[io.HF]) {
[info] 	return currHfIdx == segLen ? seq[io.HF]{} :
[info] 		let hf := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw)) in
[info] 		seq[io.HF]{hf} ++ hopFields(raw, offset, currHfIdx + 1, segLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= offset
[info] requires 0 < segLen
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires offset + path.HopLen * segLen <= len(raw)
[info] ensures  len(res.Future) == segLen - currHfIdx
[info] ensures  len(res.History) == currHfIdx
[info] ensures  len(res.Past) == currHfIdx
[info] decreases
[info] pure func segment(raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	ainfo io.Ainfo,
[info] 	uinfo set[io.MsgTerm],
[info] 	consDir bool,
[info] 	peer bool,
[info] 	segLen int) (res io.Seg) {
[info] 	return let hopfields := hopFields(raw, offset, 0, segLen) in
[info] 		io.Seg {
[info] 			AInfo: ainfo,
[info] 			UInfo: uinfo,
[info] 			ConsDir: consDir,
[info] 			Peer: peer,
[info] 			Past: segPast(hopfields[:currHfIdx]),
[info] 			Future: hopfields[currHfIdx:],
[info] 			History: segHistory(hopfields[:currHfIdx]),
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= offset
[info] requires 0 < segLen
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires offset + path.HopLen * segLen <= len(raw)
[info] ensures  len(res.Future) == segLen - currHfIdx
[info] ensures  len(res.History) == currHfIdx
[info] ensures  len(res.Past) == currHfIdx
[info] decreases
[info] pure func segment(raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	ainfo io.Ainfo,
[info] 	uinfo set[io.MsgTerm],
[info] 	consDir bool,
[info] 	peer bool,
[info] 	segLen int) (res io.Seg) {
[info] 	return let hopfields := hopFields(raw, offset, 0, segLen) in
[info] 		io.Seg {
[info] 			AInfo: ainfo,
[info] 			UInfo: uinfo,
[info] 			ConsDir: consDir,
[info] 			Peer: peer,
[info] 			Past: segPast(hopfields[:currHfIdx]),
[info] 			Future: hopfields[currHfIdx:],
[info] 			History: segHistory(hopfields[:currHfIdx]),
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= offset
[info] requires 0 < segLen
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires offset + path.HopLen * segLen <= len(raw)
[info] ensures  len(res.Future) == segLen - currHfIdx
[info] ensures  len(res.History) == currHfIdx
[info] ensures  len(res.Past) == currHfIdx
[info] decreases
[info] pure func segment(raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	ainfo io.Ainfo,
[info] 	uinfo set[io.MsgTerm],
[info] 	consDir bool,
[info] 	peer bool,
[info] 	segLen int) (res io.Seg) {
[info] 	return let hopfields := hopFields(raw, offset, 0, segLen) in
[info] 		io.Seg {
[info] 			AInfo: ainfo,
[info] 			UInfo: uinfo,
[info] 			ConsDir: consDir,
[info] 			Peer: peer,
[info] 			Past: segPast(hopfields[:currHfIdx]),
[info] 			Future: hopfields[currHfIdx:],
[info] 			History: segHistory(hopfields[:currHfIdx]),
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= offset
[info] requires 0 < segLen
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires offset + path.HopLen * segLen <= len(raw)
[info] ensures  len(res.Future) == segLen - currHfIdx
[info] ensures  len(res.History) == currHfIdx
[info] ensures  len(res.Past) == currHfIdx
[info] decreases
[info] pure func segment(raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	ainfo io.Ainfo,
[info] 	uinfo set[io.MsgTerm],
[info] 	consDir bool,
[info] 	peer bool,
[info] 	segLen int) (res io.Seg) {
[info] 	return let hopfields := hopFields(raw, offset, 0, segLen) in
[info] 		io.Seg {
[info] 			AInfo: ainfo,
[info] 			UInfo: uinfo,
[info] 			ConsDir: consDir,
[info] 			Peer: peer,
[info] 			Past: segPast(hopfields[:currHfIdx]),
[info] 			Future: hopfields[currHfIdx:],
[info] 			History: segHistory(hopfields[:currHfIdx]),
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(res.Future) == segLen - currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(res.History) == currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(res.Past) == currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(res.Future) == segLen - currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(res.History) == currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(res.Past) == currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, headerOffset) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 1 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 4 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires 0 < segLen
[info] requires offset + path.HopLen * segLen <= len(raw)
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires 0 <= currInfIdx && currInfIdx < 3
[info] ensures  len(res.Future) == segLen - currHfIdx
[info] ensures  len(res.History) == currHfIdx
[info] ensures  len(res.Past) == currHfIdx
[info] decreases
[info] pure func CurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int) (res io.Seg) {
[info] 	return let ainfo := path.Timestamp(raw, currInfIdx, headerOffset) in
[info] 		let consDir := path.ConsDir(raw, currInfIdx, headerOffset) in
[info] 		let peer := path.Peer(raw, currInfIdx, headerOffset) in
[info] 		let uinfo := path.AbsUinfo(raw, currInfIdx, headerOffset) in
[info] 		segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires 0 < segLen
[info] requires offset + path.HopLen * segLen <= len(raw)
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires 0 <= currInfIdx && currInfIdx < 3
[info] ensures  len(res.Future) == segLen - currHfIdx
[info] ensures  len(res.History) == currHfIdx
[info] ensures  len(res.Past) == currHfIdx
[info] decreases
[info] pure func CurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int) (res io.Seg) {
[info] 	return let ainfo := path.Timestamp(raw, currInfIdx, headerOffset) in
[info] 		let consDir := path.ConsDir(raw, currInfIdx, headerOffset) in
[info] 		let peer := path.Peer(raw, currInfIdx, headerOffset) in
[info] 		let uinfo := path.AbsUinfo(raw, currInfIdx, headerOffset) in
[info] 		segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires 0 < segLen
[info] requires offset + path.HopLen * segLen <= len(raw)
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires 0 <= currInfIdx && currInfIdx < 3
[info] ensures  len(res.Future) == segLen - currHfIdx
[info] ensures  len(res.History) == currHfIdx
[info] ensures  len(res.Past) == currHfIdx
[info] decreases
[info] pure func CurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int) (res io.Seg) {
[info] 	return let ainfo := path.Timestamp(raw, currInfIdx, headerOffset) in
[info] 		let consDir := path.ConsDir(raw, currInfIdx, headerOffset) in
[info] 		let peer := path.Peer(raw, currInfIdx, headerOffset) in
[info] 		let uinfo := path.AbsUinfo(raw, currInfIdx, headerOffset) in
[info] 		segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires 0 < segLen
[info] requires offset + path.HopLen * segLen <= len(raw)
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires 0 <= currInfIdx && currInfIdx < 3
[info] ensures  len(res.Future) == segLen - currHfIdx
[info] ensures  len(res.History) == currHfIdx
[info] ensures  len(res.Past) == currHfIdx
[info] decreases
[info] pure func CurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int) (res io.Seg) {
[info] 	return let ainfo := path.Timestamp(raw, currInfIdx, headerOffset) in
[info] 		let consDir := path.ConsDir(raw, currInfIdx, headerOffset) in
[info] 		let peer := path.Peer(raw, currInfIdx, headerOffset) in
[info] 		let uinfo := path.AbsUinfo(raw, currInfIdx, headerOffset) in
[info] 		segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires 0 < segLen
[info] requires offset + path.HopLen * segLen <= len(raw)
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires 0 <= currInfIdx && currInfIdx < 3
[info] ensures  len(res.Future) == segLen - currHfIdx
[info] ensures  len(res.History) == currHfIdx
[info] ensures  len(res.Past) == currHfIdx
[info] decreases
[info] pure func CurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int) (res io.Seg) {
[info] 	return let ainfo := path.Timestamp(raw, currInfIdx, headerOffset) in
[info] 		let consDir := path.ConsDir(raw, currInfIdx, headerOffset) in
[info] 		let peer := path.Peer(raw, currInfIdx, headerOffset) in
[info] 		let uinfo := path.AbsUinfo(raw, currInfIdx, headerOffset) in
[info] 		segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires 0 < segLen
[info] requires offset + path.HopLen * segLen <= len(raw)
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires 0 <= currInfIdx && currInfIdx < 3
[info] ensures  len(res.Future) == segLen - currHfIdx
[info] ensures  len(res.History) == currHfIdx
[info] ensures  len(res.Past) == currHfIdx
[info] decreases
[info] pure func CurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int) (res io.Seg) {
[info] 	return let ainfo := path.Timestamp(raw, currInfIdx, headerOffset) in
[info] 		let consDir := path.ConsDir(raw, currInfIdx, headerOffset) in
[info] 		let peer := path.Peer(raw, currInfIdx, headerOffset) in
[info] 		let uinfo := path.AbsUinfo(raw, currInfIdx, headerOffset) in
[info] 		segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, headerOffset) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion -1 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 2 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires MetaLen <= len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func RawBytesToMetaHdr(raw []byte) MetaHdr {
[info] 	return unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		let hdr := binary.BigEndian.Uint32(raw[:MetaLen]) in
[info] 		DecodedFrom(hdr)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion MetaLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion MetaLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires MetaLen <= len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func RawBytesToBase(raw []byte) Base {
[info] 	return let metaHdr := RawBytesToMetaHdr(raw) in
[info] 		let seg1 := int(metaHdr.SegLen[0])       in
[info] 		let seg2 := int(metaHdr.SegLen[1])       in
[info] 		let seg3 := int(metaHdr.SegLen[2])       in
[info] 		let segs := io.CombineSegLens(seg1, seg2, seg3) in
[info] 		Base{metaHdr, segs.NumInfoFields(), segs.TotalHops()}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] decreases
[info] pure func LeftSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 			some(CurrSeg(raw, offset + path.HopLen * segs.Seg1Len, currInfIdx, 0, segs.Seg2Len, headerOffset)) :
[info] 			((currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 				some(CurrSeg(raw, offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len), currInfIdx, 0, segs.Seg3Len, headerOffset)) :
[info] 				none[io.Seg])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] decreases
[info] pure func LeftSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 			some(CurrSeg(raw, offset + path.HopLen * segs.Seg1Len, currInfIdx, 0, segs.Seg2Len, headerOffset)) :
[info] 			((currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 				some(CurrSeg(raw, offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len), currInfIdx, 0, segs.Seg3Len, headerOffset)) :
[info] 				none[io.Seg])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] decreases
[info] pure func LeftSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 			some(CurrSeg(raw, offset + path.HopLen * segs.Seg1Len, currInfIdx, 0, segs.Seg2Len, headerOffset)) :
[info] 			((currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 				some(CurrSeg(raw, offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len), currInfIdx, 0, segs.Seg3Len, headerOffset)) :
[info] 				none[io.Seg])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] decreases
[info] pure func LeftSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 			some(CurrSeg(raw, offset + path.HopLen * segs.Seg1Len, currInfIdx, 0, segs.Seg2Len, headerOffset)) :
[info] 			((currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 				some(CurrSeg(raw, offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len), currInfIdx, 0, segs.Seg3Len, headerOffset)) :
[info] 				none[io.Seg])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func validPktMetaHdr(raw []byte) bool {
[info] 	return MetaLen <= len(raw)  &&
[info] 		let metaHdr := RawBytesToMetaHdr(raw) in
[info] 		let seg1 := int(metaHdr.SegLen[0])    in
[info] 		let seg2 := int(metaHdr.SegLen[1])    in
[info] 		let seg3 := int(metaHdr.SegLen[2])    in
[info] 		let segs := io.CombineSegLens(seg1, seg2, seg3) in
[info] 		let base := RawBytesToBase(raw)       in
[info] 		0 < metaHdr.SegLen[0] &&
[info] 		base.Valid()          &&
[info] 		PktLen(segs, MetaLen) <= len(raw)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, headerOffset) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 2 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 5 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] decreases
[info] pure func RightSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSeg(raw, offset + path.HopLen * segs.Seg1Len, currInfIdx, segs.Seg2Len, segs.Seg2Len, headerOffset)) :
[info] 			(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 				some(CurrSeg(raw, offset, currInfIdx, segs.Seg1Len, segs.Seg1Len, headerOffset)) :
[info] 				none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] decreases
[info] pure func RightSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSeg(raw, offset + path.HopLen * segs.Seg1Len, currInfIdx, segs.Seg2Len, segs.Seg2Len, headerOffset)) :
[info] 			(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 				some(CurrSeg(raw, offset, currInfIdx, segs.Seg1Len, segs.Seg1Len, headerOffset)) :
[info] 				none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] decreases
[info] pure func RightSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSeg(raw, offset + path.HopLen * segs.Seg1Len, currInfIdx, segs.Seg2Len, segs.Seg2Len, headerOffset)) :
[info] 			(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 				some(CurrSeg(raw, offset, currInfIdx, segs.Seg1Len, segs.Seg1Len, headerOffset)) :
[info] 				none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] decreases
[info] pure func RightSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSeg(raw, offset + path.HopLen * segs.Seg1Len, currInfIdx, segs.Seg2Len, segs.Seg2Len, headerOffset)) :
[info] 			(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 				some(CurrSeg(raw, offset, currInfIdx, segs.Seg1Len, segs.Seg1Len, headerOffset)) :
[info] 				none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] decreases
[info] pure func MidSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSeg(raw, offset, 0, segs.Seg1Len, segs.Seg1Len, headerOffset)) :
[info] 			((currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 				some(CurrSeg(raw, offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len), currInfIdx, 0, segs.Seg3Len, headerOffset)) :
[info] 				none[io.Seg])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] decreases
[info] pure func MidSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSeg(raw, offset, 0, segs.Seg1Len, segs.Seg1Len, headerOffset)) :
[info] 			((currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 				some(CurrSeg(raw, offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len), currInfIdx, 0, segs.Seg3Len, headerOffset)) :
[info] 				none[io.Seg])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] decreases
[info] pure func MidSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSeg(raw, offset, 0, segs.Seg1Len, segs.Seg1Len, headerOffset)) :
[info] 			((currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 				some(CurrSeg(raw, offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len), currInfIdx, 0, segs.Seg3Len, headerOffset)) :
[info] 				none[io.Seg])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires 0 <= headerOffset
[info] requires segs.Valid()
[info] requires PktLen(segs, headerOffset) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] decreases
[info] pure func MidSeg(
[info] 	raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int) option[io.Seg] {
[info] 	return let offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset) in
[info] 		(currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSeg(raw, offset, 0, segs.Seg1Len, segs.Seg1Len, headerOffset)) :
[info] 			((currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 				some(CurrSeg(raw, offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len), currInfIdx, 0, segs.Seg3Len, headerOffset)) :
[info] 				none[io.Seg])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion oldPkt.LeftSeg != none[io.Seg] might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion oldPkt.PathNotFullyTraversed() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  MetaLen <= idx && idx <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves acc(sl.Bytes(raw[:idx], 0, idx), R56)
[info] ensures   RawBytesToMetaHdr(raw) == RawBytesToMetaHdr(raw[:idx])
[info] ensures   RawBytesToBase(raw) == RawBytesToBase(raw[:idx])
[info] decreases
[info] func ValidPktMetaHdrSublice(raw []byte, idx int) {
[info] 	reveal validPktMetaHdr(raw)
[info] 	reveal validPktMetaHdr(raw[:idx])
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(raw[:idx], 0, idx), R56)
[info] 	assert forall i int :: { &raw[:MetaLen][i] } 0 <= i && i < MetaLen ==>
[info] 		&raw[:MetaLen][i] == &raw[:idx][:MetaLen][i]
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(raw[:idx], 0, idx), R56)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  MetaLen <= idx && idx <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves acc(sl.Bytes(raw[:idx], 0, idx), R56)
[info] ensures   RawBytesToMetaHdr(raw) == RawBytesToMetaHdr(raw[:idx])
[info] ensures   RawBytesToBase(raw) == RawBytesToBase(raw[:idx])
[info] decreases
[info] func ValidPktMetaHdrSublice(raw []byte, idx int) {
[info] 	reveal validPktMetaHdr(raw)
[info] 	reveal validPktMetaHdr(raw[:idx])
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(raw[:idx], 0, idx), R56)
[info] 	assert forall i int :: { &raw[:MetaLen][i] } 0 <= i && i < MetaLen ==>
[info] 		&raw[:MetaLen][i] == &raw[:idx][:MetaLen][i]
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(raw[:idx], 0, idx), R56)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires oldPkt.LeftSeg != none[io.Seg]
[info] requires oldPkt.PathNotFullyTraversed()
[info] decreases
[info] pure func AbsXover(oldPkt io.Pkt) (newPkt io.Pkt) {
[info] 	return io.Pkt {
[info] 		get(oldPkt.LeftSeg),
[info] 		oldPkt.MidSeg,
[info] 		oldPkt.RightSeg,
[info] 		some(absIncPathSeg(oldPkt.CurrSeg)),
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires len(currseg.Future) > 0
[info] decreases
[info] pure func absIncPathSeg(currseg io.Seg) io.Seg {
[info] 	return io.Seg {
[info] 		AInfo: currseg.AInfo,
[info] 		UInfo: currseg.UInfo,
[info] 		ConsDir: currseg.ConsDir,
[info] 		Peer: currseg.Peer,
[info] 		Past: seq[io.HF]{currseg.Future[0]} ++ currseg.Past,
[info] 		Future: currseg.Future[1:],
[info] 		History: seq[io.AHI]{currseg.Future[0].Toab()} ++ currseg.History,
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires oldPkt.PathNotFullyTraversed()
[info] decreases
[info] pure func AbsIncPath(oldPkt io.Pkt) (newPkt io.Pkt) {
[info] 	return io.Pkt {
[info] 		absIncPathSeg(oldPkt.CurrSeg),
[info] 		oldPkt.LeftSeg,
[info] 		oldPkt.MidSeg,
[info] 		oldPkt.RightSeg,
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion RawBytesToMetaHdr(raw) == RawBytesToMetaHdr(raw[:idx]) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx < segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
[info] decreases
[info] func LenCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx < segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
[info] decreases
[info] func LenCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx < segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
[info] decreases
[info] func LenCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx < segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
[info] decreases
[info] func LenCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx < segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
[info] decreases
[info] func LenCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < segs.Seg2Len might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, 0) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 2 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 1 <= currInfIdx ==> 0 < segs.Seg3Len might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion LeftSeg(raw, currInfIdx + 1, segs, 0) != none[io.Seg] might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion RightSeg(raw, currInfIdx, segs, 0) != none[io.Seg] might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  0 <= currInfIdx && currInfIdx < 2
[info] requires  1 <= currInfIdx ==> 0 < segs.Seg3Len
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   LeftSeg(raw, currInfIdx + 1, segs, 0) != none[io.Seg]
[info] ensures   RightSeg(raw, currInfIdx, segs, 0) != none[io.Seg]
[info] decreases
[info] func XoverSegNotNone(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx + 1, segs, 0)
[info] 	reveal RightSeg(raw, currInfIdx, segs, 0)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  0 <= currInfIdx && currInfIdx < 2
[info] requires  1 <= currInfIdx ==> 0 < segs.Seg3Len
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   LeftSeg(raw, currInfIdx + 1, segs, 0) != none[io.Seg]
[info] ensures   RightSeg(raw, currInfIdx, segs, 0) != none[io.Seg]
[info] decreases
[info] func XoverSegNotNone(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx + 1, segs, 0)
[info] 	reveal RightSeg(raw, currInfIdx, segs, 0)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  0 <= currInfIdx && currInfIdx < 2
[info] requires  1 <= currInfIdx ==> 0 < segs.Seg3Len
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   LeftSeg(raw, currInfIdx + 1, segs, 0) != none[io.Seg]
[info] ensures   RightSeg(raw, currInfIdx, segs, 0) != none[io.Seg]
[info] decreases
[info] func XoverSegNotNone(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx + 1, segs, 0)
[info] 	reveal RightSeg(raw, currInfIdx, segs, 0)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx < segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx + 1, segLen, 0) ==
[info] 	absIncPathSeg(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0))
[info] decreases
[info] func IncCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
[info] 	currseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
[info] 	incseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx + 1, segLen, 0)
[info] 	hf := hopFields(raw, offset, 0, segLen)
[info] 	hfPast := hf[:currHfIdx + 1]
[info] 	assert hfPast[:len(hfPast) - 1] == hf[:currHfIdx]
[info] 	assert currseg.AInfo == incseg.AInfo
[info] 	assert currseg.UInfo == incseg.UInfo
[info] 	assert currseg.ConsDir == incseg.ConsDir
[info] 	assert currseg.Peer == incseg.Peer
[info] 	assert seq[io.HF]{currseg.Future[0]} ++ currseg.Past == incseg.Past
[info] 	assert currseg.Future[1:] == incseg.Future
[info] 	assert seq[io.AHI]{currseg.Future[0].Toab()} ++ currseg.History == incseg.History
[info] 	assert incseg == absIncPathSeg(currseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx < segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx + 1, segLen, 0) ==
[info] 	absIncPathSeg(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0))
[info] decreases
[info] func IncCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
[info] 	currseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
[info] 	incseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx + 1, segLen, 0)
[info] 	hf := hopFields(raw, offset, 0, segLen)
[info] 	hfPast := hf[:currHfIdx + 1]
[info] 	assert hfPast[:len(hfPast) - 1] == hf[:currHfIdx]
[info] 	assert currseg.AInfo == incseg.AInfo
[info] 	assert currseg.UInfo == incseg.UInfo
[info] 	assert currseg.ConsDir == incseg.ConsDir
[info] 	assert currseg.Peer == incseg.Peer
[info] 	assert seq[io.HF]{currseg.Future[0]} ++ currseg.Past == incseg.Past
[info] 	assert currseg.Future[1:] == incseg.Future
[info] 	assert seq[io.AHI]{currseg.Future[0].Toab()} ++ currseg.History == incseg.History
[info] 	assert incseg == absIncPathSeg(currseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx < segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx + 1, segLen, 0) ==
[info] 	absIncPathSeg(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0))
[info] decreases
[info] func IncCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
[info] 	currseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
[info] 	incseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx + 1, segLen, 0)
[info] 	hf := hopFields(raw, offset, 0, segLen)
[info] 	hfPast := hf[:currHfIdx + 1]
[info] 	assert hfPast[:len(hfPast) - 1] == hf[:currHfIdx]
[info] 	assert currseg.AInfo == incseg.AInfo
[info] 	assert currseg.UInfo == incseg.UInfo
[info] 	assert currseg.ConsDir == incseg.ConsDir
[info] 	assert currseg.Peer == incseg.Peer
[info] 	assert seq[io.HF]{currseg.Future[0]} ++ currseg.Past == incseg.Past
[info] 	assert currseg.Future[1:] == incseg.Future
[info] 	assert seq[io.AHI]{currseg.Future[0].Toab()} ++ currseg.History == incseg.History
[info] 	assert incseg == absIncPathSeg(currseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx < segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx + 1, segLen, 0) ==
[info] 	absIncPathSeg(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0))
[info] decreases
[info] func IncCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
[info] 	currseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
[info] 	incseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx + 1, segLen, 0)
[info] 	hf := hopFields(raw, offset, 0, segLen)
[info] 	hfPast := hf[:currHfIdx + 1]
[info] 	assert hfPast[:len(hfPast) - 1] == hf[:currHfIdx]
[info] 	assert currseg.AInfo == incseg.AInfo
[info] 	assert currseg.UInfo == incseg.UInfo
[info] 	assert currseg.ConsDir == incseg.ConsDir
[info] 	assert currseg.Peer == incseg.Peer
[info] 	assert seq[io.HF]{currseg.Future[0]} ++ currseg.Past == incseg.Past
[info] 	assert currseg.Future[1:] == incseg.Future
[info] 	assert seq[io.AHI]{currseg.Future[0].Toab()} ++ currseg.History == incseg.History
[info] 	assert incseg == absIncPathSeg(currseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx < segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves len(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0).Future) > 0
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx + 1, segLen, 0) ==
[info] 	absIncPathSeg(CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0))
[info] decreases
[info] func IncCurrSeg(raw []byte, offset int, currInfIdx int, currHfIdx int, segLen int) {
[info] 	currseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, 0)
[info] 	incseg := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx + 1, segLen, 0)
[info] 	hf := hopFields(raw, offset, 0, segLen)
[info] 	hfPast := hf[:currHfIdx + 1]
[info] 	assert hfPast[:len(hfPast) - 1] == hf[:currHfIdx]
[info] 	assert currseg.AInfo == incseg.AInfo
[info] 	assert currseg.UInfo == incseg.UInfo
[info] 	assert currseg.ConsDir == incseg.ConsDir
[info] 	assert currseg.Peer == incseg.Peer
[info] 	assert seq[io.HF]{currseg.Future[0]} ++ currseg.Past == incseg.Past
[info] 	assert currseg.Future[1:] == incseg.Future
[info] 	assert seq[io.AHI]{currseg.Future[0].Toab()} ++ currseg.History == incseg.History
[info] 	assert incseg == absIncPathSeg(currseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion path.InfoFieldOffset(currInfIdx, 0) + path.InfoLen <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < segs.Seg2Len might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, 0) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 1 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 1 == currInfIdx ==> currHfIdx + 1 == segs.Seg1Len might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 2 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx + 1 == segs.Seg1Len + segs.Seg2Len might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion LeftSeg(raw, currInfIdx, segs, 0) != none[io.Seg] might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 3
[info] requires  1 == currInfIdx ==> currHfIdx + 1 == segs.Seg1Len
[info] requires  2 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx + 1 == segs.Seg1Len + segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves LeftSeg(raw, currInfIdx, segs, 0) != none[io.Seg]
[info] ensures
[info] 	let prevSegLen := segs.LengthOfPrevSeg(currHfIdx + 1) in
[info] 	let segLen := segs.LengthOfCurrSeg(currHfIdx + 1) in
[info] 	let numInf := segs.NumInfoFields() in
[info] 	let offset := HopFieldOffset(numInf, prevSegLen, 0) in
[info] 	CurrSeg(raw, offset, currInfIdx, currHfIdx - prevSegLen + 1, segLen, 0) ==
[info] 		get(LeftSeg(raw, currInfIdx, segs, 0))
[info] decreases
[info] func XoverCurrSeg(raw []byte, currInfIdx int, currHfIdx int, segs io.SegLens) {
[info] 	prevSegLen := segs.LengthOfPrevSeg(currHfIdx + 1)
[info] 	segLen := segs.LengthOfCurrSeg(currHfIdx + 1)
[info] 	numInf := segs.NumInfoFields()
[info] 	offset := HopFieldOffset(numInf, prevSegLen, 0)
[info] 	currseg := reveal CurrSeg(raw, offset, currInfIdx, 0, segLen, 0)
[info] 	leftseg := reveal LeftSeg(raw, currInfIdx, segs, 0)
[info] 	assert currseg == get(leftseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 3
[info] requires  1 == currInfIdx ==> currHfIdx + 1 == segs.Seg1Len
[info] requires  2 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx + 1 == segs.Seg1Len + segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves LeftSeg(raw, currInfIdx, segs, 0) != none[io.Seg]
[info] ensures
[info] 	let prevSegLen := segs.LengthOfPrevSeg(currHfIdx + 1) in
[info] 	let segLen := segs.LengthOfCurrSeg(currHfIdx + 1) in
[info] 	let numInf := segs.NumInfoFields() in
[info] 	let offset := HopFieldOffset(numInf, prevSegLen, 0) in
[info] 	CurrSeg(raw, offset, currInfIdx, currHfIdx - prevSegLen + 1, segLen, 0) ==
[info] 		get(LeftSeg(raw, currInfIdx, segs, 0))
[info] decreases
[info] func XoverCurrSeg(raw []byte, currInfIdx int, currHfIdx int, segs io.SegLens) {
[info] 	prevSegLen := segs.LengthOfPrevSeg(currHfIdx + 1)
[info] 	segLen := segs.LengthOfCurrSeg(currHfIdx + 1)
[info] 	numInf := segs.NumInfoFields()
[info] 	offset := HopFieldOffset(numInf, prevSegLen, 0)
[info] 	currseg := reveal CurrSeg(raw, offset, currInfIdx, 0, segLen, 0)
[info] 	leftseg := reveal LeftSeg(raw, currInfIdx, segs, 0)
[info] 	assert currseg == get(leftseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 3
[info] requires  1 == currInfIdx ==> currHfIdx + 1 == segs.Seg1Len
[info] requires  2 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx + 1 == segs.Seg1Len + segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves LeftSeg(raw, currInfIdx, segs, 0) != none[io.Seg]
[info] ensures
[info] 	let prevSegLen := segs.LengthOfPrevSeg(currHfIdx + 1) in
[info] 	let segLen := segs.LengthOfCurrSeg(currHfIdx + 1) in
[info] 	let numInf := segs.NumInfoFields() in
[info] 	let offset := HopFieldOffset(numInf, prevSegLen, 0) in
[info] 	CurrSeg(raw, offset, currInfIdx, currHfIdx - prevSegLen + 1, segLen, 0) ==
[info] 		get(LeftSeg(raw, currInfIdx, segs, 0))
[info] decreases
[info] func XoverCurrSeg(raw []byte, currInfIdx int, currHfIdx int, segs io.SegLens) {
[info] 	prevSegLen := segs.LengthOfPrevSeg(currHfIdx + 1)
[info] 	segLen := segs.LengthOfCurrSeg(currHfIdx + 1)
[info] 	numInf := segs.NumInfoFields()
[info] 	offset := HopFieldOffset(numInf, prevSegLen, 0)
[info] 	currseg := reveal CurrSeg(raw, offset, currInfIdx, 0, segLen, 0)
[info] 	leftseg := reveal LeftSeg(raw, currInfIdx, segs, 0)
[info] 	assert currseg == get(leftseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 3
[info] requires  1 == currInfIdx ==> currHfIdx + 1 == segs.Seg1Len
[info] requires  2 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx + 1 == segs.Seg1Len + segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves LeftSeg(raw, currInfIdx, segs, 0) != none[io.Seg]
[info] ensures
[info] 	let prevSegLen := segs.LengthOfPrevSeg(currHfIdx + 1) in
[info] 	let segLen := segs.LengthOfCurrSeg(currHfIdx + 1) in
[info] 	let numInf := segs.NumInfoFields() in
[info] 	let offset := HopFieldOffset(numInf, prevSegLen, 0) in
[info] 	CurrSeg(raw, offset, currInfIdx, currHfIdx - prevSegLen + 1, segLen, 0) ==
[info] 		get(LeftSeg(raw, currInfIdx, segs, 0))
[info] decreases
[info] func XoverCurrSeg(raw []byte, currInfIdx int, currHfIdx int, segs io.SegLens) {
[info] 	prevSegLen := segs.LengthOfPrevSeg(currHfIdx + 1)
[info] 	segLen := segs.LengthOfCurrSeg(currHfIdx + 1)
[info] 	numInf := segs.NumInfoFields()
[info] 	offset := HopFieldOffset(numInf, prevSegLen, 0)
[info] 	currseg := reveal CurrSeg(raw, offset, currInfIdx, 0, segLen, 0)
[info] 	leftseg := reveal LeftSeg(raw, currInfIdx, segs, 0)
[info] 	assert currseg == get(leftseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, 0) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 2 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 4 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   LeftSeg(raw, currInfIdx, segs, 0) ==
[info] 	MidSeg(raw, currInfIdx, segs, 0)
[info] decreases
[info] func XoverLeftSeg(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	leftseg := reveal LeftSeg(raw, currInfIdx, segs, 0)
[info] 	midseg := reveal MidSeg(raw, currInfIdx, segs, 0)
[info] 	assert leftseg == midseg
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   LeftSeg(raw, currInfIdx, segs, 0) ==
[info] 	MidSeg(raw, currInfIdx, segs, 0)
[info] decreases
[info] func XoverLeftSeg(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	leftseg := reveal LeftSeg(raw, currInfIdx, segs, 0)
[info] 	midseg := reveal MidSeg(raw, currInfIdx, segs, 0)
[info] 	assert leftseg == midseg
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   LeftSeg(raw, currInfIdx, segs, 0) ==
[info] 	MidSeg(raw, currInfIdx, segs, 0)
[info] decreases
[info] func XoverLeftSeg(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	leftseg := reveal LeftSeg(raw, currInfIdx, segs, 0)
[info] 	midseg := reveal MidSeg(raw, currInfIdx, segs, 0)
[info] 	assert leftseg == midseg
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < segs.Seg2Len might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, 0) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion -1 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 1 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 == currInfIdx ==> 0 < segs.Seg3Len might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 1
[info] requires  0 == currInfIdx ==> 0 < segs.Seg3Len
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   MidSeg(raw, currInfIdx + 4, segs, 0) ==
[info] 	RightSeg(raw, currInfIdx, segs, 0)
[info] decreases
[info] func XoverMidSeg(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	midseg := reveal MidSeg(raw, currInfIdx + 4, segs, 0)
[info] 	rightseg := reveal RightSeg(raw, currInfIdx, segs, 0)
[info] 	assert midseg == rightseg
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 1
[info] requires  0 == currInfIdx ==> 0 < segs.Seg3Len
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   MidSeg(raw, currInfIdx + 4, segs, 0) ==
[info] 	RightSeg(raw, currInfIdx, segs, 0)
[info] decreases
[info] func XoverMidSeg(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	midseg := reveal MidSeg(raw, currInfIdx + 4, segs, 0)
[info] 	rightseg := reveal RightSeg(raw, currInfIdx, segs, 0)
[info] 	assert midseg == rightseg
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 1
[info] requires  0 == currInfIdx ==> 0 < segs.Seg3Len
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] ensures   MidSeg(raw, currInfIdx + 4, segs, 0) ==
[info] 	RightSeg(raw, currInfIdx, segs, 0)
[info] decreases
[info] func XoverMidSeg(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	midseg := reveal MidSeg(raw, currInfIdx + 4, segs, 0)
[info] 	rightseg := reveal RightSeg(raw, currInfIdx, segs, 0)
[info] 	assert midseg == rightseg
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= end might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion end <= segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= end
[info] requires  end <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[:end - currHfIdx] ==
[info] 	hopFields(raw, offset, currHfIdx, end)
[info] decreases
[info] func HopsFromSuffixOfRawMatchSuffixOfHops(raw []byte, offset int, currHfIdx int, segLen int, end int) {
[info] 	hopsFromSuffixOfRawMatchSuffixOfHops(raw, offset, currHfIdx, segLen, end, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= end
[info] requires  end <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[:end - currHfIdx] ==
[info] 	hopFields(raw, offset, currHfIdx, end)
[info] decreases
[info] func HopsFromSuffixOfRawMatchSuffixOfHops(raw []byte, offset int, currHfIdx int, segLen int, end int) {
[info] 	hopsFromSuffixOfRawMatchSuffixOfHops(raw, offset, currHfIdx, segLen, end, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= end
[info] requires  end <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[:end - currHfIdx] ==
[info] 	hopFields(raw, offset, currHfIdx, end)
[info] decreases
[info] func HopsFromSuffixOfRawMatchSuffixOfHops(raw []byte, offset int, currHfIdx int, segLen int, end int) {
[info] 	hopsFromSuffixOfRawMatchSuffixOfHops(raw, offset, currHfIdx, segLen, end, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= end
[info] requires  end <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[:end - currHfIdx] ==
[info] 	hopFields(raw, offset, currHfIdx, end)
[info] decreases
[info] func HopsFromSuffixOfRawMatchSuffixOfHops(raw []byte, offset int, currHfIdx int, segLen int, end int) {
[info] 	hopsFromSuffixOfRawMatchSuffixOfHops(raw, offset, currHfIdx, segLen, end, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= end
[info] requires  end <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[:end - currHfIdx] ==
[info] 	hopFields(raw, offset, currHfIdx, end)
[info] decreases
[info] func HopsFromSuffixOfRawMatchSuffixOfHops(raw []byte, offset int, currHfIdx int, segLen int, end int) {
[info] 	hopsFromSuffixOfRawMatchSuffixOfHops(raw, offset, currHfIdx, segLen, end, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  0 <= currInfIdx && currInfIdx < 2
[info] requires  0 == currInfIdx ==> currHfIdx + 1 == segs.Seg1Len
[info] requires  1 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx + 1 == segs.Seg1Len + segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves RightSeg(raw, currInfIdx, segs, 0) != none[io.Seg]
[info] ensures
[info] 	let prevSegLen := segs.LengthOfPrevSeg(currHfIdx) in
[info] 	let segLen := segs.LengthOfCurrSeg(currHfIdx) in
[info] 	let numInf := segs.NumInfoFields() in
[info] 	let offset := HopFieldOffset(numInf, prevSegLen, 0) in
[info] 	let currseg := CurrSeg(raw, offset, currInfIdx, currHfIdx - prevSegLen, segLen, 0) in
[info] 	len(currseg.Future) > 0 &&
[info] 	get(RightSeg(raw, currInfIdx, segs, 0)) == absIncPathSeg(currseg)
[info] decreases
[info] func XoverRightSeg(raw []byte, currInfIdx int, currHfIdx int, segs io.SegLens) {
[info] 	prevSegLen := segs.LengthOfPrevSeg(currHfIdx)
[info] 	segLen := segs.LengthOfCurrSeg(currHfIdx)
[info] 	numInf := segs.NumInfoFields()
[info] 	offset := HopFieldOffset(numInf, prevSegLen, 0)
[info] 	LenCurrSeg(raw, offset, currInfIdx, segLen - 1, segLen)
[info] 	IncCurrSeg(raw, offset, currInfIdx, segLen - 1, segLen)
[info] 	currseg := CurrSeg(raw, offset, currInfIdx, segLen - 1, segLen, 0)
[info] 	nextseg := CurrSeg(raw, offset, currInfIdx, segLen, segLen, 0)
[info] 	rightseg := reveal RightSeg(raw, currInfIdx, segs, 0)
[info] 	assert absIncPathSeg(currseg) == nextseg
[info] 	assert nextseg == get(rightseg)
[info] 	assert absIncPathSeg(currseg) == get(rightseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  0 <= currInfIdx && currInfIdx < 2
[info] requires  0 == currInfIdx ==> currHfIdx + 1 == segs.Seg1Len
[info] requires  1 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx + 1 == segs.Seg1Len + segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves RightSeg(raw, currInfIdx, segs, 0) != none[io.Seg]
[info] ensures
[info] 	let prevSegLen := segs.LengthOfPrevSeg(currHfIdx) in
[info] 	let segLen := segs.LengthOfCurrSeg(currHfIdx) in
[info] 	let numInf := segs.NumInfoFields() in
[info] 	let offset := HopFieldOffset(numInf, prevSegLen, 0) in
[info] 	let currseg := CurrSeg(raw, offset, currInfIdx, currHfIdx - prevSegLen, segLen, 0) in
[info] 	len(currseg.Future) > 0 &&
[info] 	get(RightSeg(raw, currInfIdx, segs, 0)) == absIncPathSeg(currseg)
[info] decreases
[info] func XoverRightSeg(raw []byte, currInfIdx int, currHfIdx int, segs io.SegLens) {
[info] 	prevSegLen := segs.LengthOfPrevSeg(currHfIdx)
[info] 	segLen := segs.LengthOfCurrSeg(currHfIdx)
[info] 	numInf := segs.NumInfoFields()
[info] 	offset := HopFieldOffset(numInf, prevSegLen, 0)
[info] 	LenCurrSeg(raw, offset, currInfIdx, segLen - 1, segLen)
[info] 	IncCurrSeg(raw, offset, currInfIdx, segLen - 1, segLen)
[info] 	currseg := CurrSeg(raw, offset, currInfIdx, segLen - 1, segLen, 0)
[info] 	nextseg := CurrSeg(raw, offset, currInfIdx, segLen, segLen, 0)
[info] 	rightseg := reveal RightSeg(raw, currInfIdx, segs, 0)
[info] 	assert absIncPathSeg(currseg) == nextseg
[info] 	assert nextseg == get(rightseg)
[info] 	assert absIncPathSeg(currseg) == get(rightseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  0 <= currInfIdx && currInfIdx < 2
[info] requires  0 == currInfIdx ==> currHfIdx + 1 == segs.Seg1Len
[info] requires  1 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx + 1 == segs.Seg1Len + segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves RightSeg(raw, currInfIdx, segs, 0) != none[io.Seg]
[info] ensures
[info] 	let prevSegLen := segs.LengthOfPrevSeg(currHfIdx) in
[info] 	let segLen := segs.LengthOfCurrSeg(currHfIdx) in
[info] 	let numInf := segs.NumInfoFields() in
[info] 	let offset := HopFieldOffset(numInf, prevSegLen, 0) in
[info] 	let currseg := CurrSeg(raw, offset, currInfIdx, currHfIdx - prevSegLen, segLen, 0) in
[info] 	len(currseg.Future) > 0 &&
[info] 	get(RightSeg(raw, currInfIdx, segs, 0)) == absIncPathSeg(currseg)
[info] decreases
[info] func XoverRightSeg(raw []byte, currInfIdx int, currHfIdx int, segs io.SegLens) {
[info] 	prevSegLen := segs.LengthOfPrevSeg(currHfIdx)
[info] 	segLen := segs.LengthOfCurrSeg(currHfIdx)
[info] 	numInf := segs.NumInfoFields()
[info] 	offset := HopFieldOffset(numInf, prevSegLen, 0)
[info] 	LenCurrSeg(raw, offset, currInfIdx, segLen - 1, segLen)
[info] 	IncCurrSeg(raw, offset, currInfIdx, segLen - 1, segLen)
[info] 	currseg := CurrSeg(raw, offset, currInfIdx, segLen - 1, segLen, 0)
[info] 	nextseg := CurrSeg(raw, offset, currInfIdx, segLen, segLen, 0)
[info] 	rightseg := reveal RightSeg(raw, currInfIdx, segs, 0)
[info] 	assert absIncPathSeg(currseg) == nextseg
[info] 	assert nextseg == get(rightseg)
[info] 	assert absIncPathSeg(currseg) == get(rightseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  0 < segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] requires  0 <= currInfIdx && currInfIdx < 2
[info] requires  0 == currInfIdx ==> currHfIdx + 1 == segs.Seg1Len
[info] requires  1 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx + 1 == segs.Seg1Len + segs.Seg2Len
[info] requires  PktLen(segs, 0) <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] preserves RightSeg(raw, currInfIdx, segs, 0) != none[io.Seg]
[info] ensures
[info] 	let prevSegLen := segs.LengthOfPrevSeg(currHfIdx) in
[info] 	let segLen := segs.LengthOfCurrSeg(currHfIdx) in
[info] 	let numInf := segs.NumInfoFields() in
[info] 	let offset := HopFieldOffset(numInf, prevSegLen, 0) in
[info] 	let currseg := CurrSeg(raw, offset, currInfIdx, currHfIdx - prevSegLen, segLen, 0) in
[info] 	len(currseg.Future) > 0 &&
[info] 	get(RightSeg(raw, currInfIdx, segs, 0)) == absIncPathSeg(currseg)
[info] decreases
[info] func XoverRightSeg(raw []byte, currInfIdx int, currHfIdx int, segs io.SegLens) {
[info] 	prevSegLen := segs.LengthOfPrevSeg(currHfIdx)
[info] 	segLen := segs.LengthOfCurrSeg(currHfIdx)
[info] 	numInf := segs.NumInfoFields()
[info] 	offset := HopFieldOffset(numInf, prevSegLen, 0)
[info] 	LenCurrSeg(raw, offset, currInfIdx, segLen - 1, segLen)
[info] 	IncCurrSeg(raw, offset, currInfIdx, segLen - 1, segLen)
[info] 	currseg := CurrSeg(raw, offset, currInfIdx, segLen - 1, segLen, 0)
[info] 	nextseg := CurrSeg(raw, offset, currInfIdx, segLen, segLen, 0)
[info] 	rightseg := reveal RightSeg(raw, currInfIdx, segs, 0)
[info] 	assert absIncPathSeg(currseg) == nextseg
[info] 	assert nextseg == get(rightseg)
[info] 	assert absIncPathSeg(currseg) == get(rightseg)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < segs.Seg2Len might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, 0) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 2 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 == currInfIdx ==> currHfIdx + 1 == segs.Seg1Len might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 1 == currInfIdx ==> 0 < segs.Seg3Len && currHfIdx + 1 == segs.Seg1Len + segs.Seg2Len might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion RightSeg(raw, currInfIdx, segs, 0) != none[io.Seg] might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion R55 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= end might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion end <= segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= start
[info] requires  0 <= currHfIdx && currHfIdx <= segLen - start
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[start:] ==
[info]  	hopFields(raw, offset, currHfIdx + start, segLen)
[info] decreases
[info] func HopsFromPrefixOfRawMatchPrefixOfHops(raw []byte, offset int, currHfIdx int, segLen int, start int) {
[info] 	hopsFromPrefixOfRawMatchPrefixOfHops(raw, offset, currHfIdx, segLen, start, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= start
[info] requires  0 <= currHfIdx && currHfIdx <= segLen - start
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[start:] ==
[info]  	hopFields(raw, offset, currHfIdx + start, segLen)
[info] decreases
[info] func HopsFromPrefixOfRawMatchPrefixOfHops(raw []byte, offset int, currHfIdx int, segLen int, start int) {
[info] 	hopsFromPrefixOfRawMatchPrefixOfHops(raw, offset, currHfIdx, segLen, start, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= start
[info] requires  0 <= currHfIdx && currHfIdx <= segLen - start
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[start:] ==
[info]  	hopFields(raw, offset, currHfIdx + start, segLen)
[info] decreases
[info] func HopsFromPrefixOfRawMatchPrefixOfHops(raw []byte, offset int, currHfIdx int, segLen int, start int) {
[info] 	hopsFromPrefixOfRawMatchPrefixOfHops(raw, offset, currHfIdx, segLen, start, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= start
[info] requires  0 <= currHfIdx && currHfIdx <= segLen - start
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[start:] ==
[info]  	hopFields(raw, offset, currHfIdx + start, segLen)
[info] decreases
[info] func HopsFromPrefixOfRawMatchPrefixOfHops(raw []byte, offset int, currHfIdx int, segLen int, start int) {
[info] 	hopsFromPrefixOfRawMatchPrefixOfHops(raw, offset, currHfIdx, segLen, start, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= start
[info] requires  0 <= currHfIdx && currHfIdx <= segLen - start
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[start:] ==
[info]  	hopFields(raw, offset, currHfIdx + start, segLen)
[info] decreases
[info] func HopsFromPrefixOfRawMatchPrefixOfHops(raw []byte, offset int, currHfIdx int, segLen int, start int) {
[info] 	hopsFromPrefixOfRawMatchPrefixOfHops(raw, offset, currHfIdx, segLen, start, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= end
[info] requires  end <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[:end - currHfIdx] ==
[info] 	hopFields(raw, offset, currHfIdx, end)
[info] decreases end - currHfIdx
[info] func hopsFromSuffixOfRawMatchSuffixOfHops(raw []byte, offset int, currHfIdx int, segLen int, end int, p perm) {
[info] 	if (currHfIdx != end) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromSuffixOfRawMatchSuffixOfHops(raw, offset, currHfIdx + 1, segLen, end, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= end
[info] requires  end <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[:end - currHfIdx] ==
[info] 	hopFields(raw, offset, currHfIdx, end)
[info] decreases end - currHfIdx
[info] func hopsFromSuffixOfRawMatchSuffixOfHops(raw []byte, offset int, currHfIdx int, segLen int, end int, p perm) {
[info] 	if (currHfIdx != end) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromSuffixOfRawMatchSuffixOfHops(raw, offset, currHfIdx + 1, segLen, end, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= end
[info] requires  end <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[:end - currHfIdx] ==
[info] 	hopFields(raw, offset, currHfIdx, end)
[info] decreases end - currHfIdx
[info] func hopsFromSuffixOfRawMatchSuffixOfHops(raw []byte, offset int, currHfIdx int, segLen int, end int, p perm) {
[info] 	if (currHfIdx != end) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromSuffixOfRawMatchSuffixOfHops(raw, offset, currHfIdx + 1, segLen, end, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= end
[info] requires  end <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[:end - currHfIdx] ==
[info] 	hopFields(raw, offset, currHfIdx, end)
[info] decreases end - currHfIdx
[info] func hopsFromSuffixOfRawMatchSuffixOfHops(raw []byte, offset int, currHfIdx int, segLen int, end int, p perm) {
[info] 	if (currHfIdx != end) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromSuffixOfRawMatchSuffixOfHops(raw, offset, currHfIdx + 1, segLen, end, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= end
[info] requires  end <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[:end - currHfIdx] ==
[info] 	hopFields(raw, offset, currHfIdx, end)
[info] decreases end - currHfIdx
[info] func hopsFromSuffixOfRawMatchSuffixOfHops(raw []byte, offset int, currHfIdx int, segLen int, end int, p perm) {
[info] 	if (currHfIdx != end) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromSuffixOfRawMatchSuffixOfHops(raw, offset, currHfIdx + 1, segLen, end, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= end
[info] requires  end <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[:end - currHfIdx] ==
[info] 	hopFields(raw, offset, currHfIdx, end)
[info] decreases end - currHfIdx
[info] func hopsFromSuffixOfRawMatchSuffixOfHops(raw []byte, offset int, currHfIdx int, segLen int, end int, p perm) {
[info] 	if (currHfIdx != end) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromSuffixOfRawMatchSuffixOfHops(raw, offset, currHfIdx + 1, segLen, end, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= segLen - start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion R55 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= segLen - start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start
[info] requires  0 <= currHfIdx && currHfIdx <= segLen - start
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[start:] ==
[info]  	hopFields(raw, offset, currHfIdx + start, segLen)
[info] decreases start
[info] func hopsFromPrefixOfRawMatchPrefixOfHops(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (start != 0) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromPrefixOfRawMatchPrefixOfHops(raw, offset, currHfIdx, segLen, start - 1, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start
[info] requires  0 <= currHfIdx && currHfIdx <= segLen - start
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[start:] ==
[info]  	hopFields(raw, offset, currHfIdx + start, segLen)
[info] decreases start
[info] func hopsFromPrefixOfRawMatchPrefixOfHops(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (start != 0) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromPrefixOfRawMatchPrefixOfHops(raw, offset, currHfIdx, segLen, start - 1, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start
[info] requires  0 <= currHfIdx && currHfIdx <= segLen - start
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[start:] ==
[info]  	hopFields(raw, offset, currHfIdx + start, segLen)
[info] decreases start
[info] func hopsFromPrefixOfRawMatchPrefixOfHops(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (start != 0) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromPrefixOfRawMatchPrefixOfHops(raw, offset, currHfIdx, segLen, start - 1, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start
[info] requires  0 <= currHfIdx && currHfIdx <= segLen - start
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[start:] ==
[info]  	hopFields(raw, offset, currHfIdx + start, segLen)
[info] decreases start
[info] func hopsFromPrefixOfRawMatchPrefixOfHops(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (start != 0) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromPrefixOfRawMatchPrefixOfHops(raw, offset, currHfIdx, segLen, start - 1, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start
[info] requires  0 <= currHfIdx && currHfIdx <= segLen - start
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[start:] ==
[info]  	hopFields(raw, offset, currHfIdx + start, segLen)
[info] decreases start
[info] func hopsFromPrefixOfRawMatchPrefixOfHops(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (start != 0) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromPrefixOfRawMatchPrefixOfHops(raw, offset, currHfIdx, segLen, start - 1, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start
[info] requires  0 <= currHfIdx && currHfIdx <= segLen - start
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen)[start:] ==
[info]  	hopFields(raw, offset, currHfIdx + start, segLen)
[info] decreases start
[info] func hopsFromPrefixOfRawMatchPrefixOfHops(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (start != 0) {
[info] 		newP := (p + R55)/2
[info] 		hopsFromPrefixOfRawMatchPrefixOfHops(raw, offset, currHfIdx, segLen, start - 1, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= start && start <= currHfIdx
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info]  	hopFields(raw, offset + start * path.HopLen, currHfIdx - start, segLen - start)
[info] decreases
[info] func AlignHopsOfRawWithOffsetAndIndex(raw []byte, offset int, currHfIdx int, segLen int, start int) {
[info] 	alignHopsOfRawWithOffsetAndIndex(raw, offset, currHfIdx, segLen, start, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= start && start <= currHfIdx
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info]  	hopFields(raw, offset + start * path.HopLen, currHfIdx - start, segLen - start)
[info] decreases
[info] func AlignHopsOfRawWithOffsetAndIndex(raw []byte, offset int, currHfIdx int, segLen int, start int) {
[info] 	alignHopsOfRawWithOffsetAndIndex(raw, offset, currHfIdx, segLen, start, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= start && start <= currHfIdx
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info]  	hopFields(raw, offset + start * path.HopLen, currHfIdx - start, segLen - start)
[info] decreases
[info] func AlignHopsOfRawWithOffsetAndIndex(raw []byte, offset int, currHfIdx int, segLen int, start int) {
[info] 	alignHopsOfRawWithOffsetAndIndex(raw, offset, currHfIdx, segLen, start, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= start && start <= currHfIdx
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info]  	hopFields(raw, offset + start * path.HopLen, currHfIdx - start, segLen - start)
[info] decreases
[info] func AlignHopsOfRawWithOffsetAndIndex(raw []byte, offset int, currHfIdx int, segLen int, start int) {
[info] 	alignHopsOfRawWithOffsetAndIndex(raw, offset, currHfIdx, segLen, start, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  0 <= start && start <= currHfIdx
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R54)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info]  	hopFields(raw, offset + start * path.HopLen, currHfIdx - start, segLen - start)
[info] decreases
[info] func AlignHopsOfRawWithOffsetAndIndex(raw []byte, offset int, currHfIdx int, segLen int, start int) {
[info] 	alignHopsOfRawWithOffsetAndIndex(raw, offset, currHfIdx, segLen, start, R54)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion R55 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start && start <= currHfIdx
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info]  	hopFields(raw, offset + start * path.HopLen, currHfIdx - start, segLen - start)
[info] decreases segLen - currHfIdx
[info] func alignHopsOfRawWithOffsetAndIndex(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		newP := (p + R55)/2
[info] 		alignHopsOfRawWithOffsetAndIndex(raw, offset, currHfIdx + 1, segLen, start, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start && start <= currHfIdx
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info]  	hopFields(raw, offset + start * path.HopLen, currHfIdx - start, segLen - start)
[info] decreases segLen - currHfIdx
[info] func alignHopsOfRawWithOffsetAndIndex(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		newP := (p + R55)/2
[info] 		alignHopsOfRawWithOffsetAndIndex(raw, offset, currHfIdx + 1, segLen, start, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start && start <= currHfIdx
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info]  	hopFields(raw, offset + start * path.HopLen, currHfIdx - start, segLen - start)
[info] decreases segLen - currHfIdx
[info] func alignHopsOfRawWithOffsetAndIndex(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		newP := (p + R55)/2
[info] 		alignHopsOfRawWithOffsetAndIndex(raw, offset, currHfIdx + 1, segLen, start, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start && start <= currHfIdx
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info]  	hopFields(raw, offset + start * path.HopLen, currHfIdx - start, segLen - start)
[info] decreases segLen - currHfIdx
[info] func alignHopsOfRawWithOffsetAndIndex(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		newP := (p + R55)/2
[info] 		alignHopsOfRawWithOffsetAndIndex(raw, offset, currHfIdx + 1, segLen, start, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start && start <= currHfIdx
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info]  	hopFields(raw, offset + start * path.HopLen, currHfIdx - start, segLen - start)
[info] decreases segLen - currHfIdx
[info] func alignHopsOfRawWithOffsetAndIndex(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		newP := (p + R55)/2
[info] 		alignHopsOfRawWithOffsetAndIndex(raw, offset, currHfIdx + 1, segLen, start, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R55 < p
[info] requires  0 <= offset
[info] requires  0 <= start && start <= currHfIdx
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info]  	hopFields(raw, offset + start * path.HopLen, currHfIdx - start, segLen - start)
[info] decreases segLen - currHfIdx
[info] func alignHopsOfRawWithOffsetAndIndex(raw []byte, offset int, currHfIdx int, segLen int, start int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		newP := (p + R55)/2
[info] 		alignHopsOfRawWithOffsetAndIndex(raw, offset, currHfIdx + 1, segLen, start, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= length might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion length <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset) ==
[info] 	CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] decreases
[info] func WidenCurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	unfold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] 	ainfo1 := path.Timestamp(raw, currInfIdx, headerOffset)
[info] 	ainfo2 := path.Timestamp(raw[start:length], currInfIdx, headerOffset-start)
[info] 	sl.AssertSliceOverlap(raw, start, length)
[info] 	idxTimestamp := path.InfoFieldOffset(currInfIdx, headerOffset-start)+4
[info] 	sl.AssertSliceOverlap(raw[start:length], idxTimestamp, idxTimestamp+4)
[info] 	assert ainfo1 == ainfo2
[info] 	uinfo1 := path.AbsUinfo(raw, currInfIdx, headerOffset)
[info] 	uinfo2 := path.AbsUinfo(raw[start:length], currInfIdx, headerOffset-start)
[info] 	idxUinfo := path.InfoFieldOffset(currInfIdx, headerOffset-start)+2
[info] 	sl.AssertSliceOverlap(raw[start:length], idxUinfo, idxUinfo+2)
[info] 	assert uinfo1 == uinfo2
[info] 	consDir1 := path.ConsDir(raw, currInfIdx, headerOffset)
[info] 	consDir2 := path.ConsDir(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert consDir1 == consDir2
[info] 	peer1 := path.Peer(raw, currInfIdx, headerOffset)
[info] 	peer2 := path.Peer(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert peer1 == peer2
[info] 	widenSegment(raw, offset, currHfIdx, ainfo1, uinfo1, consDir1, peer1, segLen, start, length)
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset)
[info] 	reveal CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	fold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset) ==
[info] 	CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] decreases
[info] func WidenCurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	unfold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] 	ainfo1 := path.Timestamp(raw, currInfIdx, headerOffset)
[info] 	ainfo2 := path.Timestamp(raw[start:length], currInfIdx, headerOffset-start)
[info] 	sl.AssertSliceOverlap(raw, start, length)
[info] 	idxTimestamp := path.InfoFieldOffset(currInfIdx, headerOffset-start)+4
[info] 	sl.AssertSliceOverlap(raw[start:length], idxTimestamp, idxTimestamp+4)
[info] 	assert ainfo1 == ainfo2
[info] 	uinfo1 := path.AbsUinfo(raw, currInfIdx, headerOffset)
[info] 	uinfo2 := path.AbsUinfo(raw[start:length], currInfIdx, headerOffset-start)
[info] 	idxUinfo := path.InfoFieldOffset(currInfIdx, headerOffset-start)+2
[info] 	sl.AssertSliceOverlap(raw[start:length], idxUinfo, idxUinfo+2)
[info] 	assert uinfo1 == uinfo2
[info] 	consDir1 := path.ConsDir(raw, currInfIdx, headerOffset)
[info] 	consDir2 := path.ConsDir(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert consDir1 == consDir2
[info] 	peer1 := path.Peer(raw, currInfIdx, headerOffset)
[info] 	peer2 := path.Peer(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert peer1 == peer2
[info] 	widenSegment(raw, offset, currHfIdx, ainfo1, uinfo1, consDir1, peer1, segLen, start, length)
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset)
[info] 	reveal CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	fold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset) ==
[info] 	CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] decreases
[info] func WidenCurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	unfold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] 	ainfo1 := path.Timestamp(raw, currInfIdx, headerOffset)
[info] 	ainfo2 := path.Timestamp(raw[start:length], currInfIdx, headerOffset-start)
[info] 	sl.AssertSliceOverlap(raw, start, length)
[info] 	idxTimestamp := path.InfoFieldOffset(currInfIdx, headerOffset-start)+4
[info] 	sl.AssertSliceOverlap(raw[start:length], idxTimestamp, idxTimestamp+4)
[info] 	assert ainfo1 == ainfo2
[info] 	uinfo1 := path.AbsUinfo(raw, currInfIdx, headerOffset)
[info] 	uinfo2 := path.AbsUinfo(raw[start:length], currInfIdx, headerOffset-start)
[info] 	idxUinfo := path.InfoFieldOffset(currInfIdx, headerOffset-start)+2
[info] 	sl.AssertSliceOverlap(raw[start:length], idxUinfo, idxUinfo+2)
[info] 	assert uinfo1 == uinfo2
[info] 	consDir1 := path.ConsDir(raw, currInfIdx, headerOffset)
[info] 	consDir2 := path.ConsDir(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert consDir1 == consDir2
[info] 	peer1 := path.Peer(raw, currInfIdx, headerOffset)
[info] 	peer2 := path.Peer(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert peer1 == peer2
[info] 	widenSegment(raw, offset, currHfIdx, ainfo1, uinfo1, consDir1, peer1, segLen, start, length)
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset)
[info] 	reveal CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	fold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset) ==
[info] 	CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] decreases
[info] func WidenCurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	unfold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] 	ainfo1 := path.Timestamp(raw, currInfIdx, headerOffset)
[info] 	ainfo2 := path.Timestamp(raw[start:length], currInfIdx, headerOffset-start)
[info] 	sl.AssertSliceOverlap(raw, start, length)
[info] 	idxTimestamp := path.InfoFieldOffset(currInfIdx, headerOffset-start)+4
[info] 	sl.AssertSliceOverlap(raw[start:length], idxTimestamp, idxTimestamp+4)
[info] 	assert ainfo1 == ainfo2
[info] 	uinfo1 := path.AbsUinfo(raw, currInfIdx, headerOffset)
[info] 	uinfo2 := path.AbsUinfo(raw[start:length], currInfIdx, headerOffset-start)
[info] 	idxUinfo := path.InfoFieldOffset(currInfIdx, headerOffset-start)+2
[info] 	sl.AssertSliceOverlap(raw[start:length], idxUinfo, idxUinfo+2)
[info] 	assert uinfo1 == uinfo2
[info] 	consDir1 := path.ConsDir(raw, currInfIdx, headerOffset)
[info] 	consDir2 := path.ConsDir(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert consDir1 == consDir2
[info] 	peer1 := path.Peer(raw, currInfIdx, headerOffset)
[info] 	peer2 := path.Peer(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert peer1 == peer2
[info] 	widenSegment(raw, offset, currHfIdx, ainfo1, uinfo1, consDir1, peer1, segLen, start, length)
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset)
[info] 	reveal CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	fold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset) ==
[info] 	CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] decreases
[info] func WidenCurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	unfold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] 	ainfo1 := path.Timestamp(raw, currInfIdx, headerOffset)
[info] 	ainfo2 := path.Timestamp(raw[start:length], currInfIdx, headerOffset-start)
[info] 	sl.AssertSliceOverlap(raw, start, length)
[info] 	idxTimestamp := path.InfoFieldOffset(currInfIdx, headerOffset-start)+4
[info] 	sl.AssertSliceOverlap(raw[start:length], idxTimestamp, idxTimestamp+4)
[info] 	assert ainfo1 == ainfo2
[info] 	uinfo1 := path.AbsUinfo(raw, currInfIdx, headerOffset)
[info] 	uinfo2 := path.AbsUinfo(raw[start:length], currInfIdx, headerOffset-start)
[info] 	idxUinfo := path.InfoFieldOffset(currInfIdx, headerOffset-start)+2
[info] 	sl.AssertSliceOverlap(raw[start:length], idxUinfo, idxUinfo+2)
[info] 	assert uinfo1 == uinfo2
[info] 	consDir1 := path.ConsDir(raw, currInfIdx, headerOffset)
[info] 	consDir2 := path.ConsDir(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert consDir1 == consDir2
[info] 	peer1 := path.Peer(raw, currInfIdx, headerOffset)
[info] 	peer2 := path.Peer(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert peer1 == peer2
[info] 	widenSegment(raw, offset, currHfIdx, ainfo1, uinfo1, consDir1, peer1, segLen, start, length)
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset)
[info] 	reveal CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	fold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset) ==
[info] 	CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] decreases
[info] func WidenCurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	unfold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] 	ainfo1 := path.Timestamp(raw, currInfIdx, headerOffset)
[info] 	ainfo2 := path.Timestamp(raw[start:length], currInfIdx, headerOffset-start)
[info] 	sl.AssertSliceOverlap(raw, start, length)
[info] 	idxTimestamp := path.InfoFieldOffset(currInfIdx, headerOffset-start)+4
[info] 	sl.AssertSliceOverlap(raw[start:length], idxTimestamp, idxTimestamp+4)
[info] 	assert ainfo1 == ainfo2
[info] 	uinfo1 := path.AbsUinfo(raw, currInfIdx, headerOffset)
[info] 	uinfo2 := path.AbsUinfo(raw[start:length], currInfIdx, headerOffset-start)
[info] 	idxUinfo := path.InfoFieldOffset(currInfIdx, headerOffset-start)+2
[info] 	sl.AssertSliceOverlap(raw[start:length], idxUinfo, idxUinfo+2)
[info] 	assert uinfo1 == uinfo2
[info] 	consDir1 := path.ConsDir(raw, currInfIdx, headerOffset)
[info] 	consDir2 := path.ConsDir(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert consDir1 == consDir2
[info] 	peer1 := path.Peer(raw, currInfIdx, headerOffset)
[info] 	peer2 := path.Peer(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert peer1 == peer2
[info] 	widenSegment(raw, offset, currHfIdx, ainfo1, uinfo1, consDir1, peer1, segLen, start, length)
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset)
[info] 	reveal CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	fold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset) ==
[info] 	CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] decreases
[info] func WidenCurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	unfold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] 	ainfo1 := path.Timestamp(raw, currInfIdx, headerOffset)
[info] 	ainfo2 := path.Timestamp(raw[start:length], currInfIdx, headerOffset-start)
[info] 	sl.AssertSliceOverlap(raw, start, length)
[info] 	idxTimestamp := path.InfoFieldOffset(currInfIdx, headerOffset-start)+4
[info] 	sl.AssertSliceOverlap(raw[start:length], idxTimestamp, idxTimestamp+4)
[info] 	assert ainfo1 == ainfo2
[info] 	uinfo1 := path.AbsUinfo(raw, currInfIdx, headerOffset)
[info] 	uinfo2 := path.AbsUinfo(raw[start:length], currInfIdx, headerOffset-start)
[info] 	idxUinfo := path.InfoFieldOffset(currInfIdx, headerOffset-start)+2
[info] 	sl.AssertSliceOverlap(raw[start:length], idxUinfo, idxUinfo+2)
[info] 	assert uinfo1 == uinfo2
[info] 	consDir1 := path.ConsDir(raw, currInfIdx, headerOffset)
[info] 	consDir2 := path.ConsDir(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert consDir1 == consDir2
[info] 	peer1 := path.Peer(raw, currInfIdx, headerOffset)
[info] 	peer2 := path.Peer(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert peer1 == peer2
[info] 	widenSegment(raw, offset, currHfIdx, ainfo1, uinfo1, consDir1, peer1, segLen, start, length)
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset)
[info] 	reveal CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	fold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  path.InfoFieldOffset(currInfIdx, headerOffset) + path.InfoLen <= offset
[info] requires  0 < segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset) ==
[info] 	CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] decreases
[info] func WidenCurrSeg(raw []byte,
[info] 	offset int,
[info] 	currInfIdx int,
[info] 	currHfIdx int,
[info] 	segLen int,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	unfold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] 	ainfo1 := path.Timestamp(raw, currInfIdx, headerOffset)
[info] 	ainfo2 := path.Timestamp(raw[start:length], currInfIdx, headerOffset-start)
[info] 	sl.AssertSliceOverlap(raw, start, length)
[info] 	idxTimestamp := path.InfoFieldOffset(currInfIdx, headerOffset-start)+4
[info] 	sl.AssertSliceOverlap(raw[start:length], idxTimestamp, idxTimestamp+4)
[info] 	assert ainfo1 == ainfo2
[info] 	uinfo1 := path.AbsUinfo(raw, currInfIdx, headerOffset)
[info] 	uinfo2 := path.AbsUinfo(raw[start:length], currInfIdx, headerOffset-start)
[info] 	idxUinfo := path.InfoFieldOffset(currInfIdx, headerOffset-start)+2
[info] 	sl.AssertSliceOverlap(raw[start:length], idxUinfo, idxUinfo+2)
[info] 	assert uinfo1 == uinfo2
[info] 	consDir1 := path.ConsDir(raw, currInfIdx, headerOffset)
[info] 	consDir2 := path.ConsDir(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert consDir1 == consDir2
[info] 	peer1 := path.Peer(raw, currInfIdx, headerOffset)
[info] 	peer2 := path.Peer(raw[start:length], currInfIdx, headerOffset-start)
[info] 	assert peer1 == peer2
[info] 	widenSegment(raw, offset, currHfIdx, ainfo1, uinfo1, consDir1, peer1, segLen, start, length)
[info] 	reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, segLen, headerOffset)
[info] 	reveal CurrSeg(raw[start:length], offset-start, currInfIdx, currHfIdx, segLen, headerOffset-start)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R53)
[info] 	fold acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R53)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion length <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= length might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion R53 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * segLen <= length might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion length <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= start && start <= offset
[info] requires 0 < segLen
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires length <= len(raw)
[info] requires offset + path.HopLen * segLen <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R52)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R52)
[info] ensures  segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen) ==
[info] 	segment(raw[start:length], offset-start, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] decreases
[info] func widenSegment(raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	ainfo io.Ainfo,
[info] 	uinfo set[io.MsgTerm],
[info] 	consDir bool,
[info] 	peer bool,
[info] 	segLen int,
[info] 	start int,
[info] 	length int) {
[info] 	newP := (R52 + R53)/2
[info] 	widenHopFields(raw, offset, 0, segLen, start, length, newP)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= start && start <= offset
[info] requires 0 < segLen
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires length <= len(raw)
[info] requires offset + path.HopLen * segLen <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R52)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R52)
[info] ensures  segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen) ==
[info] 	segment(raw[start:length], offset-start, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] decreases
[info] func widenSegment(raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	ainfo io.Ainfo,
[info] 	uinfo set[io.MsgTerm],
[info] 	consDir bool,
[info] 	peer bool,
[info] 	segLen int,
[info] 	start int,
[info] 	length int) {
[info] 	newP := (R52 + R53)/2
[info] 	widenHopFields(raw, offset, 0, segLen, start, length, newP)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= start && start <= offset
[info] requires 0 < segLen
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires length <= len(raw)
[info] requires offset + path.HopLen * segLen <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R52)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R52)
[info] ensures  segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen) ==
[info] 	segment(raw[start:length], offset-start, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] decreases
[info] func widenSegment(raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	ainfo io.Ainfo,
[info] 	uinfo set[io.MsgTerm],
[info] 	consDir bool,
[info] 	peer bool,
[info] 	segLen int,
[info] 	start int,
[info] 	length int) {
[info] 	newP := (R52 + R53)/2
[info] 	widenHopFields(raw, offset, 0, segLen, start, length, newP)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= start && start <= offset
[info] requires 0 < segLen
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires length <= len(raw)
[info] requires offset + path.HopLen * segLen <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R52)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R52)
[info] ensures  segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen) ==
[info] 	segment(raw[start:length], offset-start, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] decreases
[info] func widenSegment(raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	ainfo io.Ainfo,
[info] 	uinfo set[io.MsgTerm],
[info] 	consDir bool,
[info] 	peer bool,
[info] 	segLen int,
[info] 	start int,
[info] 	length int) {
[info] 	newP := (R52 + R53)/2
[info] 	widenHopFields(raw, offset, 0, segLen, start, length, newP)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= start && start <= offset
[info] requires 0 < segLen
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires length <= len(raw)
[info] requires offset + path.HopLen * segLen <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R52)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R52)
[info] ensures  segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen) ==
[info] 	segment(raw[start:length], offset-start, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] decreases
[info] func widenSegment(raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	ainfo io.Ainfo,
[info] 	uinfo set[io.MsgTerm],
[info] 	consDir bool,
[info] 	peer bool,
[info] 	segLen int,
[info] 	start int,
[info] 	length int) {
[info] 	newP := (R52 + R53)/2
[info] 	widenHopFields(raw, offset, 0, segLen, start, length, newP)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= start && start <= offset
[info] requires 0 < segLen
[info] requires 0 <= currHfIdx && currHfIdx <= segLen
[info] requires length <= len(raw)
[info] requires offset + path.HopLen * segLen <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R52)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R52)
[info] ensures  segment(raw, offset, currHfIdx, ainfo, uinfo, consDir, peer, segLen) ==
[info] 	segment(raw[start:length], offset-start, currHfIdx, ainfo, uinfo, consDir, peer, segLen)
[info] decreases
[info] func widenSegment(raw []byte,
[info] 	offset int,
[info] 	currHfIdx int,
[info] 	ainfo io.Ainfo,
[info] 	uinfo set[io.MsgTerm],
[info] 	consDir bool,
[info] 	peer bool,
[info] 	segLen int,
[info] 	start int,
[info] 	length int) {
[info] 	newP := (R52 + R53)/2
[info] 	widenHopFields(raw, offset, 0, segLen, start, length, newP)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R53 < p
[info] requires  0 <= start && start <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info] 	hopFields(raw[start:length], offset-start, currHfIdx, segLen)
[info] decreases segLen - currHfIdx
[info] func widenHopFields(raw []byte, offset int, currHfIdx int, segLen int, start int, length int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		path.WidenBytesHopField(raw, offset + path.HopLen * currHfIdx, start, length)
[info] 		hf1 := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw))
[info] 		hf2 := path.BytesToIO_HF(raw[start:length], 0, offset + path.HopLen * currHfIdx - start, length - start)
[info] 		newP := (p + R53)/2
[info] 		widenHopFields(raw, offset, currHfIdx + 1, segLen, start, length, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R53 < p
[info] requires  0 <= start && start <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info] 	hopFields(raw[start:length], offset-start, currHfIdx, segLen)
[info] decreases segLen - currHfIdx
[info] func widenHopFields(raw []byte, offset int, currHfIdx int, segLen int, start int, length int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		path.WidenBytesHopField(raw, offset + path.HopLen * currHfIdx, start, length)
[info] 		hf1 := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw))
[info] 		hf2 := path.BytesToIO_HF(raw[start:length], 0, offset + path.HopLen * currHfIdx - start, length - start)
[info] 		newP := (p + R53)/2
[info] 		widenHopFields(raw, offset, currHfIdx + 1, segLen, start, length, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R53 < p
[info] requires  0 <= start && start <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info] 	hopFields(raw[start:length], offset-start, currHfIdx, segLen)
[info] decreases segLen - currHfIdx
[info] func widenHopFields(raw []byte, offset int, currHfIdx int, segLen int, start int, length int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		path.WidenBytesHopField(raw, offset + path.HopLen * currHfIdx, start, length)
[info] 		hf1 := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw))
[info] 		hf2 := path.BytesToIO_HF(raw[start:length], 0, offset + path.HopLen * currHfIdx - start, length - start)
[info] 		newP := (p + R53)/2
[info] 		widenHopFields(raw, offset, currHfIdx + 1, segLen, start, length, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R53 < p
[info] requires  0 <= start && start <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info] 	hopFields(raw[start:length], offset-start, currHfIdx, segLen)
[info] decreases segLen - currHfIdx
[info] func widenHopFields(raw []byte, offset int, currHfIdx int, segLen int, start int, length int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		path.WidenBytesHopField(raw, offset + path.HopLen * currHfIdx, start, length)
[info] 		hf1 := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw))
[info] 		hf2 := path.BytesToIO_HF(raw[start:length], 0, offset + path.HopLen * currHfIdx - start, length - start)
[info] 		newP := (p + R53)/2
[info] 		widenHopFields(raw, offset, currHfIdx + 1, segLen, start, length, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R53 < p
[info] requires  0 <= start && start <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info] 	hopFields(raw[start:length], offset-start, currHfIdx, segLen)
[info] decreases segLen - currHfIdx
[info] func widenHopFields(raw []byte, offset int, currHfIdx int, segLen int, start int, length int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		path.WidenBytesHopField(raw, offset + path.HopLen * currHfIdx, start, length)
[info] 		hf1 := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw))
[info] 		hf2 := path.BytesToIO_HF(raw[start:length], 0, offset + path.HopLen * currHfIdx - start, length - start)
[info] 		newP := (p + R53)/2
[info] 		widenHopFields(raw, offset, currHfIdx + 1, segLen, start, length, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R53 < p
[info] requires  0 <= start && start <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info] 	hopFields(raw[start:length], offset-start, currHfIdx, segLen)
[info] decreases segLen - currHfIdx
[info] func widenHopFields(raw []byte, offset int, currHfIdx int, segLen int, start int, length int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		path.WidenBytesHopField(raw, offset + path.HopLen * currHfIdx, start, length)
[info] 		hf1 := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw))
[info] 		hf2 := path.BytesToIO_HF(raw[start:length], 0, offset + path.HopLen * currHfIdx - start, length - start)
[info] 		newP := (p + R53)/2
[info] 		widenHopFields(raw, offset, currHfIdx + 1, segLen, start, length, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  R53 < p
[info] requires  0 <= start && start <= offset
[info] requires  0 <= currHfIdx && currHfIdx <= segLen
[info] requires  offset + path.HopLen * segLen <= length
[info] requires  length <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), p)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), p)
[info] ensures   hopFields(raw, offset, currHfIdx, segLen) ==
[info] 	hopFields(raw[start:length], offset-start, currHfIdx, segLen)
[info] decreases segLen - currHfIdx
[info] func widenHopFields(raw []byte, offset int, currHfIdx int, segLen int, start int, length int, p perm) {
[info] 	if (currHfIdx != segLen) {
[info] 		path.WidenBytesHopField(raw, offset + path.HopLen * currHfIdx, start, length)
[info] 		hf1 := path.BytesToIO_HF(raw, 0, offset + path.HopLen * currHfIdx, len(raw))
[info] 		hf2 := path.BytesToIO_HF(raw[start:length], 0, offset + path.HopLen * currHfIdx - start, length - start)
[info] 		newP := (p + R53)/2
[info] 		widenHopFields(raw, offset, currHfIdx + 1, segLen, start, length, newP)
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= length might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion length <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, headerOffset) <= length might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 1 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 4 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= length might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion length <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, headerOffset) <= length might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion -1 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 2 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   LeftSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	LeftSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenLeftSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal LeftSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal LeftSeg(raw[start:length], currInfIdx, segs, headerOffset- start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   LeftSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	LeftSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenLeftSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal LeftSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal LeftSeg(raw[start:length], currInfIdx, segs, headerOffset- start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   LeftSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	LeftSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenLeftSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal LeftSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal LeftSeg(raw[start:length], currInfIdx, segs, headerOffset- start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   LeftSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	LeftSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenLeftSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal LeftSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal LeftSeg(raw[start:length], currInfIdx, segs, headerOffset- start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   LeftSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	LeftSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenLeftSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal LeftSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal LeftSeg(raw[start:length], currInfIdx, segs, headerOffset- start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   LeftSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	LeftSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenLeftSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal LeftSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal LeftSeg(raw[start:length], currInfIdx, segs, headerOffset- start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 2 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 5 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= length might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion length <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, headerOffset) <= length might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currInfIdx
[info] requires path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= len(raw)
[info] decreases
[info] pure func InfofieldByteSlice(raw []byte, currInfIdx int) ([]byte) {
[info] 	return let infOffset := currInfIdx == 4 ?
[info] 		path.InfoFieldOffset(0, MetaLen) :
[info] 		path.InfoFieldOffset(currInfIdx, MetaLen) in
[info] 		raw[infOffset:infOffset + path.InfoLen]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currInfIdx
[info] requires path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= len(raw)
[info] decreases
[info] pure func InfofieldByteSlice(raw []byte, currInfIdx int) ([]byte) {
[info] 	return let infOffset := currInfIdx == 4 ?
[info] 		path.InfoFieldOffset(0, MetaLen) :
[info] 		path.InfoFieldOffset(currInfIdx, MetaLen) in
[info] 		raw[infOffset:infOffset + path.InfoLen]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires 0 <= currInfIdx
[info] decreases
[info] pure func HopfieldsStartIdx(currInfIdx int, segs io.SegLens) int {
[info] 	return let numInf := segs.NumInfoFields() in
[info] 		let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
[info] 		(currInfIdx == 0 || currInfIdx == 4) ? infOffset :
[info] 		currInfIdx == 1 ? infOffset + segs.Seg1Len * path.HopLen :
[info] 		infOffset + (segs.Seg1Len + segs.Seg2Len) * path.HopLen
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires 0 <= currInfIdx
[info] decreases
[info] pure func HopfieldsStartIdx(currInfIdx int, segs io.SegLens) int {
[info] 	return let numInf := segs.NumInfoFields() in
[info] 		let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
[info] 		(currInfIdx == 0 || currInfIdx == 4) ? infOffset :
[info] 		currInfIdx == 1 ? infOffset + segs.Seg1Len * path.HopLen :
[info] 		infOffset + (segs.Seg1Len + segs.Seg2Len) * path.HopLen
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   RightSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	RightSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenRightSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, segs.Seg2Len, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 0 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, currInfIdx, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	}
[info] 	reveal RightSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal RightSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   RightSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	RightSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenRightSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, segs.Seg2Len, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 0 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, currInfIdx, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	}
[info] 	reveal RightSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal RightSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   RightSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	RightSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenRightSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, segs.Seg2Len, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 0 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, currInfIdx, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	}
[info] 	reveal RightSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal RightSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   RightSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	RightSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenRightSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, segs.Seg2Len, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 0 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, currInfIdx, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	}
[info] 	reveal RightSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal RightSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   RightSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	RightSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenRightSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, segs.Seg2Len, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 0 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, currInfIdx, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	}
[info] 	reveal RightSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal RightSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   RightSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	RightSeg(raw[start:length], currInfIdx, segs, headerOffset-start)
[info] decreases
[info] func WidenRightSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * segs.Seg1Len
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, segs.Seg2Len, segs.Seg2Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 0 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, currInfIdx, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	}
[info] 	reveal RightSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal RightSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires 0 <= currInfIdx
[info] decreases
[info] pure func HopfieldsEndIdx(currInfIdx int, segs io.SegLens) int {
[info] 	return let numInf := segs.NumInfoFields() in
[info] 		let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
[info] 		(currInfIdx == 0 || currInfIdx == 4) ? infOffset + segs.Seg1Len * path.HopLen :
[info] 		currInfIdx == 1 ? infOffset + (segs.Seg1Len + segs.Seg2Len) * path.HopLen :
[info] 		infOffset + (segs.Seg1Len + segs.Seg2Len + segs.Seg3Len) * path.HopLen
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires 0 <= currInfIdx
[info] decreases
[info] pure func HopfieldsEndIdx(currInfIdx int, segs io.SegLens) int {
[info] 	return let numInf := segs.NumInfoFields() in
[info] 		let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
[info] 		(currInfIdx == 0 || currInfIdx == 4) ? infOffset + segs.Seg1Len * path.HopLen :
[info] 		currInfIdx == 1 ? infOffset + (segs.Seg1Len + segs.Seg2Len) * path.HopLen :
[info] 		infOffset + (segs.Seg1Len + segs.Seg2Len + segs.Seg3Len) * path.HopLen
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires 0 <= currInfIdx
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] decreases
[info] pure func HopfieldsByteSlice(raw []byte, currInfIdx int, segs io.SegLens) ([]byte) {
[info] 	return let numInf := segs.NumInfoFields() in
[info] 		let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		raw[start:end]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires 0 <= currInfIdx
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] decreases
[info] pure func HopfieldsByteSlice(raw []byte, currInfIdx int, segs io.SegLens) ([]byte) {
[info] 	return let numInf := segs.NumInfoFields() in
[info] 		let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		raw[start:end]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires 0 <= currInfIdx
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] decreases
[info] pure func HopfieldsByteSlice(raw []byte, currInfIdx int, segs io.SegLens) ([]byte) {
[info] 	return let numInf := segs.NumInfoFields() in
[info] 		let infOffset := path.InfoFieldOffset(numInf, MetaLen) in
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		raw[start:end]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, MetaLen) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, MetaLen) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures  acc(sl.Bytes(raw[:HopfieldsStartIdx(0, segs)], 0, HopfieldsStartIdx(0, segs)), p)
[info] ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 0, segs), 0, segs.Seg1Len * path.HopLen), p)
[info] ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 1, segs), 0, segs.Seg2Len * path.HopLen), p)
[info] ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 2, segs), 0, segs.Seg3Len * path.HopLen), p)
[info] ensures  acc(sl.Bytes(raw[HopfieldsEndIdx(2, segs):], 0, len(raw[HopfieldsEndIdx(2, segs):])), p)
[info] decreases
[info] func SliceBytesIntoSegments(raw []byte, segs io.SegLens, p perm) {
[info] 	sl.SplitByIndex_Bytes(raw, 0, len(raw), HopfieldsStartIdx(0, segs), p)
[info] 	sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), HopfieldsEndIdx(0, segs), p)
[info] 	sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(1, segs), len(raw), HopfieldsEndIdx(1, segs), p)
[info] 	sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(2, segs), len(raw), HopfieldsEndIdx(2, segs), p)
[info] 	sl.Reslice_Bytes(raw, 0, HopfieldsStartIdx(0, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(0, segs), HopfieldsEndIdx(0, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(1, segs), HopfieldsEndIdx(1, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(2, segs), HopfieldsEndIdx(2, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsEndIdx(2, segs), len(raw), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures  acc(sl.Bytes(raw[:HopfieldsStartIdx(0, segs)], 0, HopfieldsStartIdx(0, segs)), p)
[info] ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 0, segs), 0, segs.Seg1Len * path.HopLen), p)
[info] ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 1, segs), 0, segs.Seg2Len * path.HopLen), p)
[info] ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 2, segs), 0, segs.Seg3Len * path.HopLen), p)
[info] ensures  acc(sl.Bytes(raw[HopfieldsEndIdx(2, segs):], 0, len(raw[HopfieldsEndIdx(2, segs):])), p)
[info] decreases
[info] func SliceBytesIntoSegments(raw []byte, segs io.SegLens, p perm) {
[info] 	sl.SplitByIndex_Bytes(raw, 0, len(raw), HopfieldsStartIdx(0, segs), p)
[info] 	sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), HopfieldsEndIdx(0, segs), p)
[info] 	sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(1, segs), len(raw), HopfieldsEndIdx(1, segs), p)
[info] 	sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(2, segs), len(raw), HopfieldsEndIdx(2, segs), p)
[info] 	sl.Reslice_Bytes(raw, 0, HopfieldsStartIdx(0, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(0, segs), HopfieldsEndIdx(0, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(1, segs), HopfieldsEndIdx(1, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(2, segs), HopfieldsEndIdx(2, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsEndIdx(2, segs), len(raw), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures  acc(sl.Bytes(raw[:HopfieldsStartIdx(0, segs)], 0, HopfieldsStartIdx(0, segs)), p)
[info] ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 0, segs), 0, segs.Seg1Len * path.HopLen), p)
[info] ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 1, segs), 0, segs.Seg2Len * path.HopLen), p)
[info] ensures  acc(sl.Bytes(HopfieldsByteSlice(raw, 2, segs), 0, segs.Seg3Len * path.HopLen), p)
[info] ensures  acc(sl.Bytes(raw[HopfieldsEndIdx(2, segs):], 0, len(raw[HopfieldsEndIdx(2, segs):])), p)
[info] decreases
[info] func SliceBytesIntoSegments(raw []byte, segs io.SegLens, p perm) {
[info] 	sl.SplitByIndex_Bytes(raw, 0, len(raw), HopfieldsStartIdx(0, segs), p)
[info] 	sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), HopfieldsEndIdx(0, segs), p)
[info] 	sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(1, segs), len(raw), HopfieldsEndIdx(1, segs), p)
[info] 	sl.SplitByIndex_Bytes(raw, HopfieldsStartIdx(2, segs), len(raw), HopfieldsEndIdx(2, segs), p)
[info] 	sl.Reslice_Bytes(raw, 0, HopfieldsStartIdx(0, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(0, segs), HopfieldsEndIdx(0, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(1, segs), HopfieldsEndIdx(1, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(2, segs), HopfieldsEndIdx(2, segs), p)
[info] 	sl.Reslice_Bytes(raw, HopfieldsEndIdx(2, segs), len(raw), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   MidSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] decreases
[info] func WidenMidSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 4 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, 0, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal MidSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   MidSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] decreases
[info] func WidenMidSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 4 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, 0, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal MidSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   MidSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] decreases
[info] func WidenMidSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 4 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, 0, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal MidSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   MidSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] decreases
[info] func WidenMidSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 4 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, 0, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal MidSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   MidSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] decreases
[info] func WidenMidSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 4 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, 0, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal MidSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= headerOffset
[info] requires  segs.Valid()
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] requires  0 <= length && length <= len(raw)
[info] requires  PktLen(segs, headerOffset) <= length
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R51)
[info] preserves acc(sl.Bytes(raw[start:length], 0, len(raw[start:length])), R51)
[info] ensures   MidSeg(raw, currInfIdx, segs, headerOffset) ==
[info] 	MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] decreases
[info] func WidenMidSeg(raw []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	headerOffset int,
[info] 	start int,
[info] 	length int) {
[info] 	offset := HopFieldOffset(segs.NumInfoFields(), 0, headerOffset)
[info] 	if currInfIdx == 4 && segs.Seg2Len > 0 {
[info] 		WidenCurrSeg(raw, offset, 0, segs.Seg1Len, segs.Seg1Len, headerOffset, start, length)
[info] 	} else if currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0 {
[info] 		offsetWithHopfields := offset + path.HopLen * (segs.Seg1Len + segs.Seg2Len)
[info] 		WidenCurrSeg(raw, offsetWithHopfields, currInfIdx, 0, segs.Seg3Len, headerOffset, start, length)
[info] 	}
[info] 	reveal MidSeg(raw, currInfIdx, segs, headerOffset)
[info] 	reveal MidSeg(raw[start:length], currInfIdx, segs, headerOffset - start)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, MetaLen) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion MetaLen + numInf * path.InfoLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion numInf == segs.NumInfoFields() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures  acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] ensures  acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] ensures  1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] ensures  2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] ensures  acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] decreases
[info] func SliceBytesIntoInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.SplitByIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] 	sl.SplitByIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Reslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.Reslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	if(numInf > 1) {
[info] 		sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.Reslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	if(numInf > 2) {
[info] 		sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 		sl.Reslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures  acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] ensures  acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] ensures  1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] ensures  2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] ensures  acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] decreases
[info] func SliceBytesIntoInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.SplitByIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] 	sl.SplitByIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Reslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.Reslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	if(numInf > 1) {
[info] 		sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.Reslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	if(numInf > 2) {
[info] 		sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 		sl.Reslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures  acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] ensures  acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] ensures  1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] ensures  2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] ensures  acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] decreases
[info] func SliceBytesIntoInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.SplitByIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] 	sl.SplitByIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Reslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.Reslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	if(numInf > 1) {
[info] 		sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.Reslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	if(numInf > 2) {
[info] 		sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 		sl.Reslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw, 0, len(raw)), p)
[info] ensures  acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] ensures  acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] ensures  1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] ensures  2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] ensures  acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] decreases
[info] func SliceBytesIntoInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.SplitByIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] 	sl.SplitByIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Reslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.Reslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	if(numInf > 1) {
[info] 		sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.Reslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	if(numInf > 2) {
[info] 		sl.SplitByIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 		sl.Reslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	sl.Reslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires 0 < SegLen
[info] requires 0 <= currHfIdx && currHfIdx <= SegLen
[info] requires SegLen * path.HopLen == len(hopfields)
[info] requires sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func CurrSegWithInfo(hopfields []byte, currHfIdx int, SegLen int, inf io.AbsInfoField) io.Seg {
[info] 	return segment(hopfields, 0, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir, inf.Peer, SegLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires 0 < SegLen
[info] requires 0 <= currHfIdx && currHfIdx <= SegLen
[info] requires SegLen * path.HopLen == len(hopfields)
[info] requires sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func CurrSegWithInfo(hopfields []byte, currHfIdx int, SegLen int, inf io.AbsInfoField) io.Seg {
[info] 	return segment(hopfields, 0, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir, inf.Peer, SegLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires 0 < SegLen
[info] requires 0 <= currHfIdx && currHfIdx <= SegLen
[info] requires SegLen * path.HopLen == len(hopfields)
[info] requires sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func CurrSegWithInfo(hopfields []byte, currHfIdx int, SegLen int, inf io.AbsInfoField) io.Seg {
[info] 	return segment(hopfields, 0, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir, inf.Peer, SegLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < SegLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= SegLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion SegLen * path.HopLen == len(hopfields) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion MetaLen + numInf * path.InfoLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion numInf == segs.NumInfoFields() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion inf != none[io.AbsInfoField] might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion inf != none[io.AbsInfoField] might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func LeftSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, 0, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func RightSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg2Len, segs.Seg2Len, get(inf))) :
[info] 		(currInfIdx == 0 && segs.Seg2Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion inf != none[io.AbsInfoField] might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires segs.Valid()
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let start := HopfieldsStartIdx(currInfIdx, segs) in
[info] 		let end := HopfieldsEndIdx(currInfIdx, segs) in
[info] 		inf != none[io.AbsInfoField] &&
[info] 		len(hopfields) == end - start &&
[info] 		sl.Bytes(hopfields, 0, len(hopfields))
[info] decreases
[info] pure func MidSegWithInfo(
[info] 	hopfields []byte,
[info] 	currInfIdx int,
[info] 	segs io.SegLens,
[info] 	inf option[io.AbsInfoField]) option[io.Seg] {
[info] 	return (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		some(CurrSegWithInfo(hopfields, segs.Seg1Len, segs.Seg1Len, get(inf))) :
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 			some(CurrSegWithInfo(hopfields, 0, segs.Seg3Len, get(inf))) :
[info] 			none[io.Seg]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < SegLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + path.HopLen * SegLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= SegLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 < SegLen
[info] requires  0 <= currHfIdx && currHfIdx <= SegLen
[info] requires  SegLen * path.HopLen == len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R50)
[info] ensures   CurrSegWithInfo(raw, currHfIdx, SegLen, inf1).UpdateCurrSeg(inf2) ==
[info] 	CurrSegWithInfo(raw, currHfIdx, SegLen, inf2)
[info] decreases
[info] func UpdateCurrSegInfo(raw []byte, currHfIdx int, SegLen int,
[info] 	inf1 io.AbsInfoField, inf2 io.AbsInfoField) {
[info] 	seg1 := reveal CurrSegWithInfo(raw, currHfIdx, SegLen, inf1)
[info] 	seg2 := reveal CurrSegWithInfo(raw, currHfIdx, SegLen, inf2)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 < SegLen
[info] requires  0 <= currHfIdx && currHfIdx <= SegLen
[info] requires  SegLen * path.HopLen == len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R50)
[info] ensures   CurrSegWithInfo(raw, currHfIdx, SegLen, inf1).UpdateCurrSeg(inf2) ==
[info] 	CurrSegWithInfo(raw, currHfIdx, SegLen, inf2)
[info] decreases
[info] func UpdateCurrSegInfo(raw []byte, currHfIdx int, SegLen int,
[info] 	inf1 io.AbsInfoField, inf2 io.AbsInfoField) {
[info] 	seg1 := reveal CurrSegWithInfo(raw, currHfIdx, SegLen, inf1)
[info] 	seg2 := reveal CurrSegWithInfo(raw, currHfIdx, SegLen, inf2)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 < SegLen
[info] requires  0 <= currHfIdx && currHfIdx <= SegLen
[info] requires  SegLen * path.HopLen == len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R50)
[info] ensures   CurrSegWithInfo(raw, currHfIdx, SegLen, inf1).UpdateCurrSeg(inf2) ==
[info] 	CurrSegWithInfo(raw, currHfIdx, SegLen, inf2)
[info] decreases
[info] func UpdateCurrSegInfo(raw []byte, currHfIdx int, SegLen int,
[info] 	inf1 io.AbsInfoField, inf2 io.AbsInfoField) {
[info] 	seg1 := reveal CurrSegWithInfo(raw, currHfIdx, SegLen, inf1)
[info] 	seg2 := reveal CurrSegWithInfo(raw, currHfIdx, SegLen, inf2)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < SegLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx <= SegLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion SegLen * path.HopLen == len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= offset
[info] requires  0 < SegLen
[info] requires  offset + path.HopLen * SegLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= SegLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R50)
[info] preserves acc(sl.Bytes(raw[offset:offset + SegLen * path.HopLen], 0, SegLen * path.HopLen), R50)
[info] preserves acc(sl.Bytes(InfofieldByteSlice(raw, currInfIdx), 0, path.InfoLen), R50)
[info] ensures   let inf := path.BytesToAbsInfoField(InfofieldByteSlice(raw, currInfIdx), 0) in
[info] 	CurrSegWithInfo(raw[offset:offset + SegLen * path.HopLen], currHfIdx, SegLen, inf) ==
[info] 	CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
[info] decreases
[info] func CurrSegEquality(raw []byte, offset int, currInfIdx int, currHfIdx int, SegLen int) {
[info] 	infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 	inf := reveal path.BytesToAbsInfoField(infoBytes, 0)
[info] 	infOffset := path.InfoFieldOffset(currInfIdx, MetaLen)
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
[info] 	path.BytesToAbsInfoFieldOffsetEq(raw, infOffset)
[info] 	assert path.BytesToAbsInfoField(raw, infOffset) ==
[info] 		path.BytesToAbsInfoField(infoBytes, 0)
[info] 	sl.AssertSliceOverlap(raw, infOffset, offset + SegLen * path.HopLen)
[info] 	currseg1 := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
[info] 	currseg2 := reveal CurrSegWithInfo(raw[offset:offset + SegLen * path.HopLen], currHfIdx, SegLen, inf)
[info] 	// Establish equality of AInfo
[info] 	sl.AssertSliceOverlap(raw, infOffset+2, infOffset+4)
[info] 	sl.AssertSliceOverlap(raw, infOffset+4, infOffset+8)
[info] 	_ := reveal path.BytesToAbsInfoField(raw, infOffset)
[info] 	assert currseg1.AInfo == path.Timestamp(raw, currInfIdx, MetaLen)
[info] 	assert currseg2.AInfo == inf.AInfo
[info] 	assert currseg1.AInfo == currseg2.AInfo
[info] 	// Establish equality of Peer
[info] 	assert currseg1.Peer == path.Peer(raw, currInfIdx, MetaLen)
[info] 	assert currseg2.Peer == inf.Peer
[info] 	assert currseg1.Peer == currseg2.Peer
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
[info] 	widenSegment(raw, offset, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir,
[info] 		inf.Peer, SegLen, offset, offset + SegLen * path.HopLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= offset
[info] requires  0 < SegLen
[info] requires  offset + path.HopLen * SegLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= SegLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R50)
[info] preserves acc(sl.Bytes(raw[offset:offset + SegLen * path.HopLen], 0, SegLen * path.HopLen), R50)
[info] preserves acc(sl.Bytes(InfofieldByteSlice(raw, currInfIdx), 0, path.InfoLen), R50)
[info] ensures   let inf := path.BytesToAbsInfoField(InfofieldByteSlice(raw, currInfIdx), 0) in
[info] 	CurrSegWithInfo(raw[offset:offset + SegLen * path.HopLen], currHfIdx, SegLen, inf) ==
[info] 	CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
[info] decreases
[info] func CurrSegEquality(raw []byte, offset int, currInfIdx int, currHfIdx int, SegLen int) {
[info] 	infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 	inf := reveal path.BytesToAbsInfoField(infoBytes, 0)
[info] 	infOffset := path.InfoFieldOffset(currInfIdx, MetaLen)
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
[info] 	path.BytesToAbsInfoFieldOffsetEq(raw, infOffset)
[info] 	assert path.BytesToAbsInfoField(raw, infOffset) ==
[info] 		path.BytesToAbsInfoField(infoBytes, 0)
[info] 	sl.AssertSliceOverlap(raw, infOffset, offset + SegLen * path.HopLen)
[info] 	currseg1 := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
[info] 	currseg2 := reveal CurrSegWithInfo(raw[offset:offset + SegLen * path.HopLen], currHfIdx, SegLen, inf)
[info] 	// Establish equality of AInfo
[info] 	sl.AssertSliceOverlap(raw, infOffset+2, infOffset+4)
[info] 	sl.AssertSliceOverlap(raw, infOffset+4, infOffset+8)
[info] 	_ := reveal path.BytesToAbsInfoField(raw, infOffset)
[info] 	assert currseg1.AInfo == path.Timestamp(raw, currInfIdx, MetaLen)
[info] 	assert currseg2.AInfo == inf.AInfo
[info] 	assert currseg1.AInfo == currseg2.AInfo
[info] 	// Establish equality of Peer
[info] 	assert currseg1.Peer == path.Peer(raw, currInfIdx, MetaLen)
[info] 	assert currseg2.Peer == inf.Peer
[info] 	assert currseg1.Peer == currseg2.Peer
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
[info] 	widenSegment(raw, offset, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir,
[info] 		inf.Peer, SegLen, offset, offset + SegLen * path.HopLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= offset
[info] requires  0 < SegLen
[info] requires  offset + path.HopLen * SegLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= SegLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R50)
[info] preserves acc(sl.Bytes(raw[offset:offset + SegLen * path.HopLen], 0, SegLen * path.HopLen), R50)
[info] preserves acc(sl.Bytes(InfofieldByteSlice(raw, currInfIdx), 0, path.InfoLen), R50)
[info] ensures   let inf := path.BytesToAbsInfoField(InfofieldByteSlice(raw, currInfIdx), 0) in
[info] 	CurrSegWithInfo(raw[offset:offset + SegLen * path.HopLen], currHfIdx, SegLen, inf) ==
[info] 	CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
[info] decreases
[info] func CurrSegEquality(raw []byte, offset int, currInfIdx int, currHfIdx int, SegLen int) {
[info] 	infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 	inf := reveal path.BytesToAbsInfoField(infoBytes, 0)
[info] 	infOffset := path.InfoFieldOffset(currInfIdx, MetaLen)
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
[info] 	path.BytesToAbsInfoFieldOffsetEq(raw, infOffset)
[info] 	assert path.BytesToAbsInfoField(raw, infOffset) ==
[info] 		path.BytesToAbsInfoField(infoBytes, 0)
[info] 	sl.AssertSliceOverlap(raw, infOffset, offset + SegLen * path.HopLen)
[info] 	currseg1 := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
[info] 	currseg2 := reveal CurrSegWithInfo(raw[offset:offset + SegLen * path.HopLen], currHfIdx, SegLen, inf)
[info] 	// Establish equality of AInfo
[info] 	sl.AssertSliceOverlap(raw, infOffset+2, infOffset+4)
[info] 	sl.AssertSliceOverlap(raw, infOffset+4, infOffset+8)
[info] 	_ := reveal path.BytesToAbsInfoField(raw, infOffset)
[info] 	assert currseg1.AInfo == path.Timestamp(raw, currInfIdx, MetaLen)
[info] 	assert currseg2.AInfo == inf.AInfo
[info] 	assert currseg1.AInfo == currseg2.AInfo
[info] 	// Establish equality of Peer
[info] 	assert currseg1.Peer == path.Peer(raw, currInfIdx, MetaLen)
[info] 	assert currseg2.Peer == inf.Peer
[info] 	assert currseg1.Peer == currseg2.Peer
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
[info] 	widenSegment(raw, offset, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir,
[info] 		inf.Peer, SegLen, offset, offset + SegLen * path.HopLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= offset
[info] requires  0 < SegLen
[info] requires  offset + path.HopLen * SegLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= SegLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R50)
[info] preserves acc(sl.Bytes(raw[offset:offset + SegLen * path.HopLen], 0, SegLen * path.HopLen), R50)
[info] preserves acc(sl.Bytes(InfofieldByteSlice(raw, currInfIdx), 0, path.InfoLen), R50)
[info] ensures   let inf := path.BytesToAbsInfoField(InfofieldByteSlice(raw, currInfIdx), 0) in
[info] 	CurrSegWithInfo(raw[offset:offset + SegLen * path.HopLen], currHfIdx, SegLen, inf) ==
[info] 	CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
[info] decreases
[info] func CurrSegEquality(raw []byte, offset int, currInfIdx int, currHfIdx int, SegLen int) {
[info] 	infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 	inf := reveal path.BytesToAbsInfoField(infoBytes, 0)
[info] 	infOffset := path.InfoFieldOffset(currInfIdx, MetaLen)
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
[info] 	path.BytesToAbsInfoFieldOffsetEq(raw, infOffset)
[info] 	assert path.BytesToAbsInfoField(raw, infOffset) ==
[info] 		path.BytesToAbsInfoField(infoBytes, 0)
[info] 	sl.AssertSliceOverlap(raw, infOffset, offset + SegLen * path.HopLen)
[info] 	currseg1 := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
[info] 	currseg2 := reveal CurrSegWithInfo(raw[offset:offset + SegLen * path.HopLen], currHfIdx, SegLen, inf)
[info] 	// Establish equality of AInfo
[info] 	sl.AssertSliceOverlap(raw, infOffset+2, infOffset+4)
[info] 	sl.AssertSliceOverlap(raw, infOffset+4, infOffset+8)
[info] 	_ := reveal path.BytesToAbsInfoField(raw, infOffset)
[info] 	assert currseg1.AInfo == path.Timestamp(raw, currInfIdx, MetaLen)
[info] 	assert currseg2.AInfo == inf.AInfo
[info] 	assert currseg1.AInfo == currseg2.AInfo
[info] 	// Establish equality of Peer
[info] 	assert currseg1.Peer == path.Peer(raw, currInfIdx, MetaLen)
[info] 	assert currseg2.Peer == inf.Peer
[info] 	assert currseg1.Peer == currseg2.Peer
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
[info] 	widenSegment(raw, offset, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir,
[info] 		inf.Peer, SegLen, offset, offset + SegLen * path.HopLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  path.InfoFieldOffset(currInfIdx, MetaLen) + path.InfoLen <= offset
[info] requires  0 < SegLen
[info] requires  offset + path.HopLen * SegLen <= len(raw)
[info] requires  0 <= currHfIdx && currHfIdx <= SegLen
[info] requires  0 <= currInfIdx && currInfIdx < 3
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R50)
[info] preserves acc(sl.Bytes(raw[offset:offset + SegLen * path.HopLen], 0, SegLen * path.HopLen), R50)
[info] preserves acc(sl.Bytes(InfofieldByteSlice(raw, currInfIdx), 0, path.InfoLen), R50)
[info] ensures   let inf := path.BytesToAbsInfoField(InfofieldByteSlice(raw, currInfIdx), 0) in
[info] 	CurrSegWithInfo(raw[offset:offset + SegLen * path.HopLen], currHfIdx, SegLen, inf) ==
[info] 	CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
[info] decreases
[info] func CurrSegEquality(raw []byte, offset int, currInfIdx int, currHfIdx int, SegLen int) {
[info] 	infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 	inf := reveal path.BytesToAbsInfoField(infoBytes, 0)
[info] 	infOffset := path.InfoFieldOffset(currInfIdx, MetaLen)
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
[info] 	path.BytesToAbsInfoFieldOffsetEq(raw, infOffset)
[info] 	assert path.BytesToAbsInfoField(raw, infOffset) ==
[info] 		path.BytesToAbsInfoField(infoBytes, 0)
[info] 	sl.AssertSliceOverlap(raw, infOffset, offset + SegLen * path.HopLen)
[info] 	currseg1 := reveal CurrSeg(raw, offset, currInfIdx, currHfIdx, SegLen, MetaLen)
[info] 	currseg2 := reveal CurrSegWithInfo(raw[offset:offset + SegLen * path.HopLen], currHfIdx, SegLen, inf)
[info] 	// Establish equality of AInfo
[info] 	sl.AssertSliceOverlap(raw, infOffset+2, infOffset+4)
[info] 	sl.AssertSliceOverlap(raw, infOffset+4, infOffset+8)
[info] 	_ := reveal path.BytesToAbsInfoField(raw, infOffset)
[info] 	assert currseg1.AInfo == path.Timestamp(raw, currInfIdx, MetaLen)
[info] 	assert currseg2.AInfo == inf.AInfo
[info] 	assert currseg1.AInfo == currseg2.AInfo
[info] 	// Establish equality of Peer
[info] 	assert currseg1.Peer == path.Peer(raw, currInfIdx, MetaLen)
[info] 	assert currseg2.Peer == inf.Peer
[info] 	assert currseg1.Peer == currseg2.Peer
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(infoBytes, 0, path.InfoLen), R56)
[info] 	widenSegment(raw, offset, currHfIdx, inf.AInfo, inf.UInfo, inf.ConsDir,
[info] 		inf.Peer, SegLen, offset, offset + SegLen * path.HopLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, MetaLen) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 1 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 4 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to sl.Bytes(infoBytes, 0, path.InfoLen) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, MetaLen) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 1 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 4 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, MetaLen) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion -1 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 2 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to sl.Bytes(infoBytes, 0, path.InfoLen) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires acc(sl.Bytes(raw[:HopfieldsStartIdx(0, segs)], 0, HopfieldsStartIdx(0, segs)), p)
[info] requires acc(sl.Bytes(HopfieldsByteSlice(raw, 0, segs), 0, segs.Seg1Len*path.HopLen), p)
[info] requires acc(sl.Bytes(HopfieldsByteSlice(raw, 1, segs), 0, segs.Seg2Len*path.HopLen), p)
[info] requires acc(sl.Bytes(HopfieldsByteSlice(raw, 2, segs), 0, segs.Seg3Len*path.HopLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsEndIdx(2, segs):], 0, len(raw[HopfieldsEndIdx(2, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromSegments(raw []byte, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsEndIdx(2, segs), len(raw), p)
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(2, segs), HopfieldsEndIdx(2, segs), p)
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(1, segs), HopfieldsEndIdx(1, segs), p)
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), HopfieldsEndIdx(0, segs), p)
[info] 	sl.Unslice_Bytes(raw, 0, HopfieldsStartIdx(0, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(2, segs), len(raw), HopfieldsEndIdx(2, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(1, segs), len(raw), HopfieldsEndIdx(1, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), HopfieldsEndIdx(0, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), HopfieldsStartIdx(0, segs), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires acc(sl.Bytes(raw[:HopfieldsStartIdx(0, segs)], 0, HopfieldsStartIdx(0, segs)), p)
[info] requires acc(sl.Bytes(HopfieldsByteSlice(raw, 0, segs), 0, segs.Seg1Len*path.HopLen), p)
[info] requires acc(sl.Bytes(HopfieldsByteSlice(raw, 1, segs), 0, segs.Seg2Len*path.HopLen), p)
[info] requires acc(sl.Bytes(HopfieldsByteSlice(raw, 2, segs), 0, segs.Seg3Len*path.HopLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsEndIdx(2, segs):], 0, len(raw[HopfieldsEndIdx(2, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromSegments(raw []byte, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsEndIdx(2, segs), len(raw), p)
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(2, segs), HopfieldsEndIdx(2, segs), p)
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(1, segs), HopfieldsEndIdx(1, segs), p)
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), HopfieldsEndIdx(0, segs), p)
[info] 	sl.Unslice_Bytes(raw, 0, HopfieldsStartIdx(0, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(2, segs), len(raw), HopfieldsEndIdx(2, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(1, segs), len(raw), HopfieldsEndIdx(1, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), HopfieldsEndIdx(0, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), HopfieldsStartIdx(0, segs), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires acc(sl.Bytes(raw[:HopfieldsStartIdx(0, segs)], 0, HopfieldsStartIdx(0, segs)), p)
[info] requires acc(sl.Bytes(HopfieldsByteSlice(raw, 0, segs), 0, segs.Seg1Len*path.HopLen), p)
[info] requires acc(sl.Bytes(HopfieldsByteSlice(raw, 1, segs), 0, segs.Seg2Len*path.HopLen), p)
[info] requires acc(sl.Bytes(HopfieldsByteSlice(raw, 2, segs), 0, segs.Seg3Len*path.HopLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsEndIdx(2, segs):], 0, len(raw[HopfieldsEndIdx(2, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromSegments(raw []byte, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsEndIdx(2, segs), len(raw), p)
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(2, segs), HopfieldsEndIdx(2, segs), p)
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(1, segs), HopfieldsEndIdx(1, segs), p)
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), HopfieldsEndIdx(0, segs), p)
[info] 	sl.Unslice_Bytes(raw, 0, HopfieldsStartIdx(0, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(2, segs), len(raw), HopfieldsEndIdx(2, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(1, segs), len(raw), HopfieldsEndIdx(1, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), HopfieldsEndIdx(0, segs), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), HopfieldsStartIdx(0, segs), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, MetaLen) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion -1 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 2 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 1 <= currInfIdx && currInfIdx < 4
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func LeftSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		LeftSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, MetaLen) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 2 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 5 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to sl.Bytes(infoBytes, 0, path.InfoLen) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  1 <= currInfIdx && currInfIdx < 4
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   LeftSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func LeftSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal LeftSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 1 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 1 ? segs.Seg2Len : segs.Seg3Len
[info] 		reveal LeftSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segLen)
[info] 	} else {
[info] 		reveal LeftSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires -1 <= currInfIdx && currInfIdx < 2
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func RightSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ?
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 		RightSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 		RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segs.Valid() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion PktLen(segs, MetaLen) <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 2 <= currInfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currInfIdx < 5 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segLen * path.HopLen == len(hopfields) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to sl.Bytes(hopfields[:currHfStart], 0, currHfStart) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  -1 <= currInfIdx && currInfIdx < 2
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 	(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   RightSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func RightSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal RightSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if ((currInfIdx == 0 && segs.Seg2Len > 0) ||
[info] 		(currInfIdx == 1 && segs.Seg2Len > 0 && segs.Seg3Len > 0)) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		segLen := currInfIdx == 0 ? segs.Seg1Len : segs.Seg2Len
[info] 		reveal RightSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, segLen, segLen)
[info] 	} else {
[info] 		reveal RightSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] requires sl.Bytes(hopfields, 0, len(hopfields))
[info] requires let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen      in
[info] 	sl.Bytes(hopfields[:currHfStart], 0, currHfStart)          &&
[info] 	sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen) &&
[info] 	sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen)
[info] decreases
[info] pure func BytesStoreCurrSeg(hopfields []byte, currHfIdx int, segLen int, inf io.AbsInfoField) bool {
[info] 	return let currseg := CurrSegWithInfo(hopfields, currHfIdx, segLen, inf) in
[info] 		let currHfStart := currHfIdx * path.HopLen                           in
[info] 		let currHfEnd := currHfStart + path.HopLen                           in
[info] 		len(currseg.Future) > 0  &&
[info] 		currseg.Future[0] == path.BytesToIO_HF(hopfields[currHfStart:currHfEnd], 0, 0, path.HopLen) &&
[info] 		currseg.Future[1:] == hopFields(hopfields[currHfEnd:], 0, 0, (segLen - currHfIdx - 1))      &&
[info] 		currseg.Past == segPast(hopFields(hopfields[:currHfStart], 0, 0, currHfIdx))                &&
[info] 		currseg.History == segHistory(hopFields(hopfields[:currHfStart], 0, 0, currHfIdx))          &&
[info] 		currseg.AInfo == inf.AInfo     &&
[info] 		currseg.UInfo == inf.UInfo     &&
[info] 		currseg.ConsDir == inf.ConsDir &&
[info] 		currseg.Peer == inf.Peer
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] requires sl.Bytes(hopfields, 0, len(hopfields))
[info] requires let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen      in
[info] 	sl.Bytes(hopfields[:currHfStart], 0, currHfStart)          &&
[info] 	sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen) &&
[info] 	sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen)
[info] decreases
[info] pure func BytesStoreCurrSeg(hopfields []byte, currHfIdx int, segLen int, inf io.AbsInfoField) bool {
[info] 	return let currseg := CurrSegWithInfo(hopfields, currHfIdx, segLen, inf) in
[info] 		let currHfStart := currHfIdx * path.HopLen                           in
[info] 		let currHfEnd := currHfStart + path.HopLen                           in
[info] 		len(currseg.Future) > 0  &&
[info] 		currseg.Future[0] == path.BytesToIO_HF(hopfields[currHfStart:currHfEnd], 0, 0, path.HopLen) &&
[info] 		currseg.Future[1:] == hopFields(hopfields[currHfEnd:], 0, 0, (segLen - currHfIdx - 1))      &&
[info] 		currseg.Past == segPast(hopFields(hopfields[:currHfStart], 0, 0, currHfIdx))                &&
[info] 		currseg.History == segHistory(hopFields(hopfields[:currHfStart], 0, 0, currHfIdx))          &&
[info] 		currseg.AInfo == inf.AInfo     &&
[info] 		currseg.UInfo == inf.UInfo     &&
[info] 		currseg.ConsDir == inf.ConsDir &&
[info] 		currseg.Peer == inf.Peer
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] requires sl.Bytes(hopfields, 0, len(hopfields))
[info] requires let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen      in
[info] 	sl.Bytes(hopfields[:currHfStart], 0, currHfStart)          &&
[info] 	sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen) &&
[info] 	sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen)
[info] decreases
[info] pure func BytesStoreCurrSeg(hopfields []byte, currHfIdx int, segLen int, inf io.AbsInfoField) bool {
[info] 	return let currseg := CurrSegWithInfo(hopfields, currHfIdx, segLen, inf) in
[info] 		let currHfStart := currHfIdx * path.HopLen                           in
[info] 		let currHfEnd := currHfStart + path.HopLen                           in
[info] 		len(currseg.Future) > 0  &&
[info] 		currseg.Future[0] == path.BytesToIO_HF(hopfields[currHfStart:currHfEnd], 0, 0, path.HopLen) &&
[info] 		currseg.Future[1:] == hopFields(hopfields[currHfEnd:], 0, 0, (segLen - currHfIdx - 1))      &&
[info] 		currseg.Past == segPast(hopFields(hopfields[:currHfStart], 0, 0, currHfIdx))                &&
[info] 		currseg.History == segHistory(hopFields(hopfields[:currHfStart], 0, 0, currHfIdx))          &&
[info] 		currseg.AInfo == inf.AInfo     &&
[info] 		currseg.UInfo == inf.UInfo     &&
[info] 		currseg.ConsDir == inf.ConsDir &&
[info] 		currseg.Peer == inf.Peer
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires segs.Valid()
[info] requires PktLen(segs, MetaLen) <= len(raw)
[info] requires 2 <= currInfIdx && currInfIdx < 5
[info] requires sl.Bytes(raw, 0, len(raw))
[info] requires (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		sl.Bytes(infoBytes, 0, path.InfoLen) &&
[info] 		sl.Bytes(hopBytes, 0, len(hopBytes))
[info] decreases
[info] pure func MidSegEqualitySpec(raw []byte, currInfIdx int, segs io.SegLens) bool {
[info] 	return (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 		(currInfIdx == 2 || currInfIdx == 4)) ?
[info] 			let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 			let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 			let inf := some(path.BytesToAbsInfoField(infoBytes, 0)) in
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(hopBytes, currInfIdx, segs, inf) :
[info] 			MidSeg(raw, currInfIdx, segs, MetaLen) ==
[info] 			MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segLen * path.HopLen == len(hopfields) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), R49) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segLen * path.HopLen == len(hopfields) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] requires acc(sl.Bytes(hopfields, 0, len(hopfields)), p)
[info] ensures  let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen in
[info] 	acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen), p)
[info] decreases
[info] func SplitHopfields(hopfields []byte, currHfIdx int, segLen int, p perm) {
[info] 	currHfStart := currHfIdx * path.HopLen
[info] 	currHfEnd := currHfStart + path.HopLen
[info] 	sl.SplitByIndex_Bytes(hopfields, 0, len(hopfields), currHfStart, p)
[info] 	sl.SplitByIndex_Bytes(hopfields, currHfStart, len(hopfields), currHfEnd, p)
[info] 	sl.Reslice_Bytes(hopfields, 0, currHfStart, p)
[info] 	sl.Reslice_Bytes(hopfields, currHfStart, currHfEnd, p)
[info] 	sl.Reslice_Bytes(hopfields, currHfEnd, len(hopfields), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] requires acc(sl.Bytes(hopfields, 0, len(hopfields)), p)
[info] ensures  let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen in
[info] 	acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen), p)
[info] decreases
[info] func SplitHopfields(hopfields []byte, currHfIdx int, segLen int, p perm) {
[info] 	currHfStart := currHfIdx * path.HopLen
[info] 	currHfEnd := currHfStart + path.HopLen
[info] 	sl.SplitByIndex_Bytes(hopfields, 0, len(hopfields), currHfStart, p)
[info] 	sl.SplitByIndex_Bytes(hopfields, currHfStart, len(hopfields), currHfEnd, p)
[info] 	sl.Reslice_Bytes(hopfields, 0, currHfStart, p)
[info] 	sl.Reslice_Bytes(hopfields, currHfStart, currHfEnd, p)
[info] 	sl.Reslice_Bytes(hopfields, currHfEnd, len(hopfields), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] requires acc(sl.Bytes(hopfields, 0, len(hopfields)), p)
[info] ensures  let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen in
[info] 	acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen), p)
[info] decreases
[info] func SplitHopfields(hopfields []byte, currHfIdx int, segLen int, p perm) {
[info] 	currHfStart := currHfIdx * path.HopLen
[info] 	currHfEnd := currHfStart + path.HopLen
[info] 	sl.SplitByIndex_Bytes(hopfields, 0, len(hopfields), currHfStart, p)
[info] 	sl.SplitByIndex_Bytes(hopfields, currHfStart, len(hopfields), currHfEnd, p)
[info] 	sl.Reslice_Bytes(hopfields, 0, currHfStart, p)
[info] 	sl.Reslice_Bytes(hopfields, currHfStart, currHfEnd, p)
[info] 	sl.Reslice_Bytes(hopfields, currHfEnd, len(hopfields), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] requires acc(sl.Bytes(hopfields, 0, len(hopfields)), p)
[info] ensures  let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen in
[info] 	acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen), p)
[info] decreases
[info] func SplitHopfields(hopfields []byte, currHfIdx int, segLen int, p perm) {
[info] 	currHfStart := currHfIdx * path.HopLen
[info] 	currHfEnd := currHfStart + path.HopLen
[info] 	sl.SplitByIndex_Bytes(hopfields, 0, len(hopfields), currHfStart, p)
[info] 	sl.SplitByIndex_Bytes(hopfields, currHfStart, len(hopfields), currHfEnd, p)
[info] 	sl.Reslice_Bytes(hopfields, 0, currHfStart, p)
[info] 	sl.Reslice_Bytes(hopfields, currHfStart, currHfEnd, p)
[info] 	sl.Reslice_Bytes(hopfields, currHfEnd, len(hopfields), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currHfIdx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion currHfIdx < segLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion segLen * path.HopLen == len(hopfields) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), p) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] preserves acc(sl.Bytes(hopfields, 0, len(hopfields)), R49)
[info] preserves let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen in
[info] 	acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), R49) &&
[info] 	acc(sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen), R49) &&
[info] 	acc(sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen), R49)
[info] ensures  BytesStoreCurrSeg(hopfields, currHfIdx, segLen, inf)
[info] decreases
[info] func EstablishBytesStoreCurrSeg(hopfields []byte, currHfIdx int, segLen int, inf io.AbsInfoField) {
[info] 	currseg := reveal CurrSegWithInfo(hopfields, currHfIdx, segLen, inf)
[info] 	currHfStart := currHfIdx * path.HopLen
[info] 	currHfEnd := currHfStart + path.HopLen
[info] 	HopsFromSuffixOfRawMatchSuffixOfHops(hopfields, 0, 0, segLen, currHfIdx)
[info] 	AlignHopsOfRawWithOffsetAndIndex(hopfields, 0, currHfIdx + 1, segLen, currHfIdx + 1)
[info] 	HopsFromPrefixOfRawMatchPrefixOfHops(hopfields, 0, 0, segLen, currHfIdx + 1)
[info] 	HopsFromPrefixOfRawMatchPrefixOfHops(hopfields, 0, 0, segLen, currHfIdx)
[info] 	widenHopFields(hopfields, 0, 0, currHfIdx, 0, currHfStart, R52)
[info] 	widenHopFields(hopfields, currHfEnd, 0, segLen - currHfIdx - 1, currHfEnd, segLen * path.HopLen, R52)
[info] 	widenHopFields(hopfields, currHfStart, 0, 1, currHfStart, currHfEnd, R52)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] preserves acc(sl.Bytes(hopfields, 0, len(hopfields)), R49)
[info] preserves let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen in
[info] 	acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), R49) &&
[info] 	acc(sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen), R49) &&
[info] 	acc(sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen), R49)
[info] ensures  BytesStoreCurrSeg(hopfields, currHfIdx, segLen, inf)
[info] decreases
[info] func EstablishBytesStoreCurrSeg(hopfields []byte, currHfIdx int, segLen int, inf io.AbsInfoField) {
[info] 	currseg := reveal CurrSegWithInfo(hopfields, currHfIdx, segLen, inf)
[info] 	currHfStart := currHfIdx * path.HopLen
[info] 	currHfEnd := currHfStart + path.HopLen
[info] 	HopsFromSuffixOfRawMatchSuffixOfHops(hopfields, 0, 0, segLen, currHfIdx)
[info] 	AlignHopsOfRawWithOffsetAndIndex(hopfields, 0, currHfIdx + 1, segLen, currHfIdx + 1)
[info] 	HopsFromPrefixOfRawMatchPrefixOfHops(hopfields, 0, 0, segLen, currHfIdx + 1)
[info] 	HopsFromPrefixOfRawMatchPrefixOfHops(hopfields, 0, 0, segLen, currHfIdx)
[info] 	widenHopFields(hopfields, 0, 0, currHfIdx, 0, currHfStart, R52)
[info] 	widenHopFields(hopfields, currHfEnd, 0, segLen - currHfIdx - 1, currHfEnd, segLen * path.HopLen, R52)
[info] 	widenHopFields(hopfields, currHfStart, 0, 1, currHfStart, currHfEnd, R52)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] preserves acc(sl.Bytes(hopfields, 0, len(hopfields)), R49)
[info] preserves let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen in
[info] 	acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), R49) &&
[info] 	acc(sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen), R49) &&
[info] 	acc(sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen), R49)
[info] ensures  BytesStoreCurrSeg(hopfields, currHfIdx, segLen, inf)
[info] decreases
[info] func EstablishBytesStoreCurrSeg(hopfields []byte, currHfIdx int, segLen int, inf io.AbsInfoField) {
[info] 	currseg := reveal CurrSegWithInfo(hopfields, currHfIdx, segLen, inf)
[info] 	currHfStart := currHfIdx * path.HopLen
[info] 	currHfEnd := currHfStart + path.HopLen
[info] 	HopsFromSuffixOfRawMatchSuffixOfHops(hopfields, 0, 0, segLen, currHfIdx)
[info] 	AlignHopsOfRawWithOffsetAndIndex(hopfields, 0, currHfIdx + 1, segLen, currHfIdx + 1)
[info] 	HopsFromPrefixOfRawMatchPrefixOfHops(hopfields, 0, 0, segLen, currHfIdx + 1)
[info] 	HopsFromPrefixOfRawMatchPrefixOfHops(hopfields, 0, 0, segLen, currHfIdx)
[info] 	widenHopFields(hopfields, 0, 0, currHfIdx, 0, currHfStart, R52)
[info] 	widenHopFields(hopfields, currHfEnd, 0, segLen - currHfIdx - 1, currHfEnd, segLen * path.HopLen, R52)
[info] 	widenHopFields(hopfields, currHfStart, 0, 1, currHfStart, currHfEnd, R52)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] requires let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen in
[info] 	acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen), p)
[info] ensures  acc(sl.Bytes(hopfields, 0, len(hopfields)), p)
[info] decreases
[info] func CombineHopfields(hopfields []byte, currHfIdx int, segLen int, p perm) {
[info] 	currHfStart := currHfIdx * path.HopLen
[info] 	currHfEnd := currHfStart + path.HopLen
[info] 	sl.Unslice_Bytes(hopfields, currHfEnd, len(hopfields), p)
[info] 	sl.Unslice_Bytes(hopfields, currHfStart, currHfEnd, p)
[info] 	sl.Unslice_Bytes(hopfields, 0, currHfStart, p)
[info] 	sl.CombineAtIndex_Bytes(hopfields, currHfStart, len(hopfields), currHfEnd, p)
[info] 	sl.CombineAtIndex_Bytes(hopfields, 0, len(hopfields), currHfStart, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] requires let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen in
[info] 	acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen), p)
[info] ensures  acc(sl.Bytes(hopfields, 0, len(hopfields)), p)
[info] decreases
[info] func CombineHopfields(hopfields []byte, currHfIdx int, segLen int, p perm) {
[info] 	currHfStart := currHfIdx * path.HopLen
[info] 	currHfEnd := currHfStart + path.HopLen
[info] 	sl.Unslice_Bytes(hopfields, currHfEnd, len(hopfields), p)
[info] 	sl.Unslice_Bytes(hopfields, currHfStart, currHfEnd, p)
[info] 	sl.Unslice_Bytes(hopfields, 0, currHfStart, p)
[info] 	sl.CombineAtIndex_Bytes(hopfields, currHfStart, len(hopfields), currHfEnd, p)
[info] 	sl.CombineAtIndex_Bytes(hopfields, 0, len(hopfields), currHfStart, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] requires let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen in
[info] 	acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen), p)
[info] ensures  acc(sl.Bytes(hopfields, 0, len(hopfields)), p)
[info] decreases
[info] func CombineHopfields(hopfields []byte, currHfIdx int, segLen int, p perm) {
[info] 	currHfStart := currHfIdx * path.HopLen
[info] 	currHfEnd := currHfStart + path.HopLen
[info] 	sl.Unslice_Bytes(hopfields, currHfEnd, len(hopfields), p)
[info] 	sl.Unslice_Bytes(hopfields, currHfStart, currHfEnd, p)
[info] 	sl.Unslice_Bytes(hopfields, 0, currHfStart, p)
[info] 	sl.CombineAtIndex_Bytes(hopfields, currHfStart, len(hopfields), currHfEnd, p)
[info] 	sl.CombineAtIndex_Bytes(hopfields, 0, len(hopfields), currHfStart, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= currHfIdx && currHfIdx < segLen
[info] requires segLen * path.HopLen == len(hopfields)
[info] requires let currHfStart := currHfIdx * path.HopLen in
[info] 	let currHfEnd := currHfStart + path.HopLen in
[info] 	acc(sl.Bytes(hopfields[:currHfStart], 0, currHfStart), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfStart:currHfEnd], 0, path.HopLen), p) &&
[info] 	acc(sl.Bytes(hopfields[currHfEnd:], 0, (segLen - currHfIdx - 1) * path.HopLen), p)
[info] ensures  acc(sl.Bytes(hopfields, 0, len(hopfields)), p)
[info] decreases
[info] func CombineHopfields(hopfields []byte, currHfIdx int, segLen int, p perm) {
[info] 	currHfStart := currHfIdx * path.HopLen
[info] 	currHfEnd := currHfStart + path.HopLen
[info] 	sl.Unslice_Bytes(hopfields, currHfEnd, len(hopfields), p)
[info] 	sl.Unslice_Bytes(hopfields, currHfStart, currHfEnd, p)
[info] 	sl.Unslice_Bytes(hopfields, 0, currHfStart, p)
[info] 	sl.CombineAtIndex_Bytes(hopfields, currHfStart, len(hopfields), currHfEnd, p)
[info] 	sl.CombineAtIndex_Bytes(hopfields, 0, len(hopfields), currHfStart, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  segs.Valid()
[info] requires  PktLen(segs, MetaLen) <= len(raw)
[info] requires  2 <= currInfIdx && currInfIdx < 5
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R49)
[info] preserves (segs.Seg2Len > 0 && segs.Seg3Len > 0 &&
[info] 	(currInfIdx == 2 || currInfIdx == 4)) ==>
[info] 		let infoBytes := InfofieldByteSlice(raw, currInfIdx) in
[info] 		let hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs) in
[info] 		acc(sl.Bytes(infoBytes, 0, path.InfoLen), R49) &&
[info] 		acc(sl.Bytes(hopBytes, 0, len(hopBytes)), R49)
[info] ensures   MidSegEqualitySpec(raw, currInfIdx, segs)
[info] decreases
[info] func MidSegEquality(raw []byte, currInfIdx int, segs io.SegLens) {
[info] 	reveal MidSeg(raw, currInfIdx, segs, MetaLen)
[info] 	if (currInfIdx == 4 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, 0)
[info] 		hopBytes := HopfieldsByteSlice(raw, 0, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, 0, segs.Seg1Len, segs.Seg1Len)
[info] 	} else if (currInfIdx == 2 && segs.Seg2Len > 0 && segs.Seg3Len > 0) {
[info] 		infoBytes := InfofieldByteSlice(raw, currInfIdx)
[info] 		hopBytes := HopfieldsByteSlice(raw, currInfIdx, segs)
[info] 		inf := some(reveal path.BytesToAbsInfoField(infoBytes, 0))
[info] 		offset := HopfieldsStartIdx(currInfIdx, segs)
[info] 		reveal MidSegWithInfo(hopBytes, currInfIdx, segs, inf)
[info] 		CurrSegEquality(raw, offset, currInfIdx, 0, segs.Seg3Len)
[info] 	} else {
[info] 		reveal MidSegWithInfo(nil, currInfIdx, segs, none[io.AbsInfoField])
[info] 	}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires forall i int :: { &elems[i] } 0 <= i && i < len(elems) ==> acc(&elems[i])
[info] ensures len(elems) == 0 ==> res == ""
[info] ensures len(elems) == 1 ==> res == elems[0]
[info] // (VerifiedSCION) Leads to precondition of call might not hold (permission to elems[i] might not suffice)
[info] // ensures len(elems) > 1 ==> res == elems[0] + sep + Join(elems[1:], sep)
[info] decreases _
[info] pure func Join(elems []string, sep string) (res string) fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires start <= end
[info] ensures  res.Inv()
[info] ensures  res.Start == start && res.End == end
[info] ensures  forall i int64 :: start <= i && i <= end ==>
[info] 	res.DoesNotContain(i)
[info] // The following is technically redundant, but very useful.
[info] ensures  forall i int64 :: start <= i && i <= end ==>
[info] 	!res.FContains(i)
[info] decreases
[info] func Alloc(start, end int64) (res BoundedMonotonicSet) {
[info] 	b := BoundedMonotonicSet{
[info] 		Start: start,
[info] 		End: end,
[info] 	}
[info] 	var i int64
[info] 	invariant start <= i && i <= end
[info] 	invariant b.Start == start && b.End == end
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		j in domain(b.valuesMap)
[info] 	// injectivity requirement
[info] 	invariant forall j1, j2 int64 :: start <= j1 && j1 < j2 && j2 < i ==>
[info] 		b.valuesMap[j1] != b.valuesMap[j2]
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		acc(b.valuesMap[j])
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		!(*b.valuesMap[j])
[info] 	decreases end - i
[info] 	for i = start; i < end; i += 1 {
[info] 		b.valuesMap[i] = new(bool)
[info] 	}
[info] 	// this repetition of the body of the loop here saves us from having
[info] 	// the potential overflowing operation b.End+1 in the loop above.
[info] 	b.valuesMap[i] = new(bool)
[info] 	invariant start <= i && i <= end
[info] 	invariant b.Start == start && b.End == end
[info] 	invariant forall j int64 :: start <= j && j <= end ==>
[info] 		j in domain(b.valuesMap)
[info] 	// injectivity requirement
[info] 	invariant forall j1, j2 int64 :: start <= j1 && j1 < j2 && j2 < i ==>
[info] 		b.valuesMap[j1] != b.valuesMap[j2]
[info] 	invariant forall j int64 :: i <= j && j <= end ==>
[info] 		acc(b.valuesMap[j]) && !(*b.valuesMap[j])
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		acc(b.valuesMap[j], 1/2)
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		b.DoesNotContain(j)
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		!b.fcontainshelper(j)
[info] 	decreases end - i
[info] 	for i = start; i < end; i += 1 {
[info] 		fold b.DoesNotContain(i)
[info] 	}
[info] 	// this repetition of the body of the loop here saves us from having
[info] 	// the potential overflowing operation b.End+1 in the loop above.
[info] 	fold b.DoesNotContain(i)
[info] 	fold b.Inv()
[info] 	return b
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires start <= end
[info] ensures  res.Inv()
[info] ensures  res.Start == start && res.End == end
[info] ensures  forall i int64 :: start <= i && i <= end ==>
[info] 	res.DoesNotContain(i)
[info] // The following is technically redundant, but very useful.
[info] ensures  forall i int64 :: start <= i && i <= end ==>
[info] 	!res.FContains(i)
[info] decreases
[info] func Alloc(start, end int64) (res BoundedMonotonicSet) {
[info] 	b := BoundedMonotonicSet{
[info] 		Start: start,
[info] 		End: end,
[info] 	}
[info] 	var i int64
[info] 	invariant start <= i && i <= end
[info] 	invariant b.Start == start && b.End == end
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		j in domain(b.valuesMap)
[info] 	// injectivity requirement
[info] 	invariant forall j1, j2 int64 :: start <= j1 && j1 < j2 && j2 < i ==>
[info] 		b.valuesMap[j1] != b.valuesMap[j2]
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		acc(b.valuesMap[j])
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		!(*b.valuesMap[j])
[info] 	decreases end - i
[info] 	for i = start; i < end; i += 1 {
[info] 		b.valuesMap[i] = new(bool)
[info] 	}
[info] 	// this repetition of the body of the loop here saves us from having
[info] 	// the potential overflowing operation b.End+1 in the loop above.
[info] 	b.valuesMap[i] = new(bool)
[info] 	invariant start <= i && i <= end
[info] 	invariant b.Start == start && b.End == end
[info] 	invariant forall j int64 :: start <= j && j <= end ==>
[info] 		j in domain(b.valuesMap)
[info] 	// injectivity requirement
[info] 	invariant forall j1, j2 int64 :: start <= j1 && j1 < j2 && j2 < i ==>
[info] 		b.valuesMap[j1] != b.valuesMap[j2]
[info] 	invariant forall j int64 :: i <= j && j <= end ==>
[info] 		acc(b.valuesMap[j]) && !(*b.valuesMap[j])
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		acc(b.valuesMap[j], 1/2)
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		b.DoesNotContain(j)
[info] 	invariant forall j int64 :: start <= j && j < i ==>
[info] 		!b.fcontainshelper(j)
[info] 	decreases end - i
[info] 	for i = start; i < end; i += 1 {
[info] 		fold b.DoesNotContain(i)
[info] 	}
[info] 	// this repetition of the body of the loop here saves us from having
[info] 	// the potential overflowing operation b.End+1 in the loop above.
[info] 	fold b.DoesNotContain(i)
[info] 	fold b.Inv()
[info] 	return b
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression preserves forall i int :: { &v[i] } 0 <= i && i < len(v) ==> acc(&v[i], R55)
[info] // TODO:
[info] // The following precondition cannot be adequately captured in Gobra.
[info] // preserves forall i int :: 0 <= i && i < len(v) ==> definitions.IsOfPrimitiveType(v[i])
[info] decreases _
[info] func Sprintf(format string, v ...interface{}) string fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(elems) == 0 ==> res == "" might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(elems) == 1 ==> res == elems[0] might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= b & 0x7 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res == b >> 30 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion b & 0x7 <= 7 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res == b & 0x7 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= res might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res <= 3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res.Start == start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res.End == end might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to res.DoesNotContain(i) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion forall i int64 :: start <= i && i <= end ==>
[info] 	!res.FContains(i) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res == b & 0x3F might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= res might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res < 64 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression trusted
[info] requires sl.Bytes(a, 0, len(a))
[info] requires sl.Bytes(b, 0, len(b))
[info] decreases
[info] pure func Equal(a, b []byte) bool {
[info] 	return string(a) == string(b)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression trusted
[info] requires sl.Bytes(a, 0, len(a))
[info] requires sl.Bytes(b, 0, len(b))
[info] decreases
[info] pure func Equal(a, b []byte) bool {
[info] 	return string(a) == string(b)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= b & 0x3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion b & 0x3 <= 3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion b == 0 ==> res == 0 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion b == 3 ==> res == 3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion b == 4 ==> res == 0 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res == b & 0x3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= i might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion i < end might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 | 1 == 1 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 | 2 == 2 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 1 | 2 == 3 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 & 1 == 0 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 & 2 == 0 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 1 & 1 == 1 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 1 & 2 == 0 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 2 & 1 == 0 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 2 & 2 == 2 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 3 & 1 == 1 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 3 & 2 == 2 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= idx might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion idx <= end might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires Bytes(s, start, end)
[info] requires start <= i && i < end
[info] decreases
[info] pure func GetByte(s []byte, start int, end int, i int) byte {
[info] 	return unfolding Bytes(s, start, end) in s[i]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires Bytes(s, start, end)
[info] requires start <= i && i < end
[info] decreases
[info] pure func GetByte(s []byte, start int, end int, i int) byte {
[info] 	return unfolding Bytes(s, start, end) in s[i]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires Bytes(s, start, end)
[info] requires start <= i && i < end
[info] decreases
[info] pure func GetByte(s []byte, start int, end int, i int) byte {
[info] 	return unfolding Bytes(s, start, end) in s[i]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires Bytes(s, start, end)
[info] requires start <= i && i < end
[info] decreases
[info] pure func GetByte(s []byte, start int, end int, i int) byte {
[info] 	return unfolding Bytes(s, start, end) in s[i]
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= end might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion end <= cap(s) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, end), p)
[info] requires start <= idx && idx <= end
[info] ensures  acc(Bytes(s, start, idx), p)
[info] ensures  acc(Bytes(s, idx, end), p)
[info] decreases
[info] func SplitByIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
[info] 	unfold acc(Bytes(s, start, end), p)
[info] 	fold   acc(Bytes(s, start, idx), p)
[info] 	fold   acc(Bytes(s, idx, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, end), p)
[info] requires start <= idx && idx <= end
[info] ensures  acc(Bytes(s, start, idx), p)
[info] ensures  acc(Bytes(s, idx, end), p)
[info] decreases
[info] func SplitByIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
[info] 	unfold acc(Bytes(s, start, end), p)
[info] 	fold   acc(Bytes(s, start, idx), p)
[info] 	fold   acc(Bytes(s, idx, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, end), p)
[info] requires start <= idx && idx <= end
[info] ensures  acc(Bytes(s, start, idx), p)
[info] ensures  acc(Bytes(s, idx, end), p)
[info] decreases
[info] func SplitByIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
[info] 	unfold acc(Bytes(s, start, end), p)
[info] 	fold   acc(Bytes(s, start, idx), p)
[info] 	fold   acc(Bytes(s, idx, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, end), p)
[info] requires start <= idx && idx <= end
[info] ensures  acc(Bytes(s, start, idx), p)
[info] ensures  acc(Bytes(s, idx, end), p)
[info] decreases
[info] func SplitByIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
[info] 	unfold acc(Bytes(s, start, end), p)
[info] 	fold   acc(Bytes(s, start, idx), p)
[info] 	fold   acc(Bytes(s, idx, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, end), p)
[info] requires start <= idx && idx <= end
[info] ensures  acc(Bytes(s, start, idx), p)
[info] ensures  acc(Bytes(s, idx, end), p)
[info] decreases
[info] func SplitByIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
[info] 	unfold acc(Bytes(s, start, end), p)
[info] 	fold   acc(Bytes(s, start, idx), p)
[info] 	fold   acc(Bytes(s, idx, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, end), p)
[info] // the following precondition convinces Gobra that
[info] // the slice operation is well-formed
[info] requires unfolding acc(Bytes(s, start, end), p) in true
[info] ensures  acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] decreases
[info] func Reslice_Bytes(s []byte, start int, end int, p perm) {
[info] 	unfold acc(Bytes(s, start, end), p)
[info] 	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < (end-start) ==> &s[start:end][i] == &s[start + i]
[info] 	fold  acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= cap(s)
[info] //requires len(s[start:end]) <= cap(s)
[info] requires acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] ensures  acc(Bytes(s, start, end), p)
[info] decreases
[info] func Unslice_Bytes(s []byte, start int, end int, p perm) {
[info] 	unfold acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] 	assert 0 <= start && start <= end && end <= cap(s)
[info] 	assert forall i int :: { &s[start:end][i] } 0 <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
[info] 	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]
[info] 	invariant 0 <= j && j <= len(s[start:end])
[info] 	invariant forall i int :: { &s[start:end][i] } j <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
[info] 	invariant forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]
[info] 	invariant forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
[info] 	decreases len(s[start:end]) - j
[info] 	for j := 0; j < len(s[start:end]); j++ {
[info] 		assert forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
[info] 		assert &s[start:end][j] == &s[start + j]
[info] 		assert acc(&s[start + j], p)
[info] 		assert forall i int :: { &s[i] } start <= i && i <= start+j ==> acc(&s[i], p)
[info] 	}
[info] 	fold acc(Bytes(s, start, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, end), p)
[info] // the following precondition convinces Gobra that
[info] // the slice operation is well-formed
[info] requires unfolding acc(Bytes(s, start, end), p) in true
[info] ensures  acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] decreases
[info] func Reslice_Bytes(s []byte, start int, end int, p perm) {
[info] 	unfold acc(Bytes(s, start, end), p)
[info] 	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < (end-start) ==> &s[start:end][i] == &s[start + i]
[info] 	fold  acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= cap(s)
[info] //requires len(s[start:end]) <= cap(s)
[info] requires acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] ensures  acc(Bytes(s, start, end), p)
[info] decreases
[info] func Unslice_Bytes(s []byte, start int, end int, p perm) {
[info] 	unfold acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] 	assert 0 <= start && start <= end && end <= cap(s)
[info] 	assert forall i int :: { &s[start:end][i] } 0 <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
[info] 	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]
[info] 	invariant 0 <= j && j <= len(s[start:end])
[info] 	invariant forall i int :: { &s[start:end][i] } j <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
[info] 	invariant forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]
[info] 	invariant forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
[info] 	decreases len(s[start:end]) - j
[info] 	for j := 0; j < len(s[start:end]); j++ {
[info] 		assert forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
[info] 		assert &s[start:end][j] == &s[start + j]
[info] 		assert acc(&s[start + j], p)
[info] 		assert forall i int :: { &s[i] } start <= i && i <= start+j ==> acc(&s[i], p)
[info] 	}
[info] 	fold acc(Bytes(s, start, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, end), p)
[info] // the following precondition convinces Gobra that
[info] // the slice operation is well-formed
[info] requires unfolding acc(Bytes(s, start, end), p) in true
[info] ensures  acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] decreases
[info] func Reslice_Bytes(s []byte, start int, end int, p perm) {
[info] 	unfold acc(Bytes(s, start, end), p)
[info] 	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < (end-start) ==> &s[start:end][i] == &s[start + i]
[info] 	fold  acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= cap(s)
[info] //requires len(s[start:end]) <= cap(s)
[info] requires acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] ensures  acc(Bytes(s, start, end), p)
[info] decreases
[info] func Unslice_Bytes(s []byte, start int, end int, p perm) {
[info] 	unfold acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] 	assert 0 <= start && start <= end && end <= cap(s)
[info] 	assert forall i int :: { &s[start:end][i] } 0 <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
[info] 	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]
[info] 	invariant 0 <= j && j <= len(s[start:end])
[info] 	invariant forall i int :: { &s[start:end][i] } j <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
[info] 	invariant forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]
[info] 	invariant forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
[info] 	decreases len(s[start:end]) - j
[info] 	for j := 0; j < len(s[start:end]); j++ {
[info] 		assert forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
[info] 		assert &s[start:end][j] == &s[start + j]
[info] 		assert acc(&s[start + j], p)
[info] 		assert forall i int :: { &s[i] } start <= i && i <= start+j ==> acc(&s[i], p)
[info] 	}
[info] 	fold acc(Bytes(s, start, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, end), p)
[info] // the following precondition convinces Gobra that
[info] // the slice operation is well-formed
[info] requires unfolding acc(Bytes(s, start, end), p) in true
[info] ensures  acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] decreases
[info] func Reslice_Bytes(s []byte, start int, end int, p perm) {
[info] 	unfold acc(Bytes(s, start, end), p)
[info] 	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < (end-start) ==> &s[start:end][i] == &s[start + i]
[info] 	fold  acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= cap(s)
[info] //requires len(s[start:end]) <= cap(s)
[info] requires acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] ensures  acc(Bytes(s, start, end), p)
[info] decreases
[info] func Unslice_Bytes(s []byte, start int, end int, p perm) {
[info] 	unfold acc(Bytes(s[start:end], 0, len(s[start:end])), p)
[info] 	assert 0 <= start && start <= end && end <= cap(s)
[info] 	assert forall i int :: { &s[start:end][i] } 0 <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
[info] 	assert forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]
[info] 	invariant 0 <= j && j <= len(s[start:end])
[info] 	invariant forall i int :: { &s[start:end][i] } j <= i && i < len(s[start:end]) ==> acc(&s[start:end][i], p)
[info] 	invariant forall i int :: { &s[start:end][i] }{ &s[start + i] } 0 <= i && i < len(s[start:end]) ==> &s[start:end][i] == &s[start + i]
[info] 	invariant forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
[info] 	decreases len(s[start:end]) - j
[info] 	for j := 0; j < len(s[start:end]); j++ {
[info] 		assert forall i int :: { &s[i] } start <= i && i < start+j ==> acc(&s[i], p)
[info] 		assert &s[start:end][j] == &s[start + j]
[info] 		assert acc(&s[start + j], p)
[info] 		assert forall i int :: { &s[i] } start <= i && i <= start+j ==> acc(&s[i], p)
[info] 	}
[info] 	fold acc(Bytes(s, start, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= end might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion end <= len(s) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= len(s)
[info] requires acc(Bytes(s, 0, len(s)), p)
[info] ensures  acc(Bytes(s[start:end], 0, end-start), p)
[info] ensures  acc(Bytes(s, 0, start), p)
[info] ensures  acc(Bytes(s, end, len(s)), p)
[info] decreases
[info] func SplitRange_Bytes(s []byte, start int, end int, p perm) {
[info] 	SplitByIndex_Bytes(s, 0, len(s), start, p)
[info] 	SplitByIndex_Bytes(s, start, len(s), end, p)
[info] 	Reslice_Bytes(s, start, end, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= len(s)
[info] requires acc(Bytes(s, 0, len(s)), p)
[info] ensures  acc(Bytes(s[start:end], 0, end-start), p)
[info] ensures  acc(Bytes(s, 0, start), p)
[info] ensures  acc(Bytes(s, end, len(s)), p)
[info] decreases
[info] func SplitRange_Bytes(s []byte, start int, end int, p perm) {
[info] 	SplitByIndex_Bytes(s, 0, len(s), start, p)
[info] 	SplitByIndex_Bytes(s, start, len(s), end, p)
[info] 	Reslice_Bytes(s, start, end, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= len(s)
[info] requires acc(Bytes(s, 0, len(s)), p)
[info] ensures  acc(Bytes(s[start:end], 0, end-start), p)
[info] ensures  acc(Bytes(s, 0, start), p)
[info] ensures  acc(Bytes(s, end, len(s)), p)
[info] decreases
[info] func SplitRange_Bytes(s []byte, start int, end int, p perm) {
[info] 	SplitByIndex_Bytes(s, 0, len(s), start, p)
[info] 	SplitByIndex_Bytes(s, start, len(s), end, p)
[info] 	Reslice_Bytes(s, start, end, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= len(s)
[info] requires acc(Bytes(s, 0, len(s)), p)
[info] ensures  acc(Bytes(s[start:end], 0, end-start), p)
[info] ensures  acc(Bytes(s, 0, start), p)
[info] ensures  acc(Bytes(s, end, len(s)), p)
[info] decreases
[info] func SplitRange_Bytes(s []byte, start int, end int, p perm) {
[info] 	SplitByIndex_Bytes(s, 0, len(s), start, p)
[info] 	SplitByIndex_Bytes(s, start, len(s), end, p)
[info] 	Reslice_Bytes(s, start, end, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= end might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion end <= len(s) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= subStart
[info] requires subStart <= subEnd
[info] requires subEnd <= cap(s)
[info] ensures  forall i int :: { &s[subStart:subEnd][i] } 0 <= i && i < len(s[subStart:subEnd]) ==>
[info] 	&s[subStart:subEnd][i] == &s[subStart+i]
[info] decreases
[info] pure func AssertSliceOverlap(ghost s []byte, ghost subStart int, ghost subEnd int) Unit {
[info] 	return Unit{}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= subStart
[info] requires subStart <= subEnd
[info] requires subEnd <= cap(s)
[info] ensures  forall i int :: { &s[subStart:subEnd][i] } 0 <= i && i < len(s[subStart:subEnd]) ==>
[info] 	&s[subStart:subEnd][i] == &s[subStart+i]
[info] decreases
[info] pure func AssertSliceOverlap(ghost s []byte, ghost subStart int, ghost subEnd int) Unit {
[info] 	return Unit{}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= subStart
[info] requires subStart <= subEnd
[info] requires subEnd <= cap(s)
[info] ensures  forall i int :: { &s[subStart:subEnd][i] } 0 <= i && i < len(s[subStart:subEnd]) ==>
[info] 	&s[subStart:subEnd][i] == &s[subStart+i]
[info] decreases
[info] pure func AssertSliceOverlap(ghost s []byte, ghost subStart int, ghost subEnd int) Unit {
[info] 	return Unit{}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 < p might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(s1) > 0 || len(s2) > 0 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= subStart might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion subStart <= subEnd might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion subEnd <= cap(s) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  len(s1) > 0 || len(s2) > 0
[info] preserves Bytes(s1, 0, len(s1))
[info] preserves acc(Bytes(s2, 0, len(s2)), _)
[info] ensures   s1 !== s2
[info] decreases
[info] func PermsImplyIneqWithWildcard(s1 []byte, s2 []byte) {
[info] 	unfold Bytes(s1, 0, len(s1))
[info] 	unfold acc(Bytes(s2, 0, len(s2)), _)
[info] 	if len(s1) > 0 && len(s2) > 0 {
[info] 		// This assertion checks that the memory addresses of the first elements
[info] 		// in s1 and s2 are different. By doing so, we instantiate the triggers in
[info] 		// the quantifier bodies to prove the required inequality for non-empty slices.
[info] 		assert &s1[0] != &s2[0]
[info] 	}
[info] 	fold Bytes(s1, 0, len(s1))
[info] 	fold acc(Bytes(s2, 0, len(s2)), _)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  len(s1) > 0 || len(s2) > 0
[info] preserves Bytes(s1, 0, len(s1))
[info] preserves acc(Bytes(s2, 0, len(s2)), _)
[info] ensures   s1 !== s2
[info] decreases
[info] func PermsImplyIneqWithWildcard(s1 []byte, s2 []byte) {
[info] 	unfold Bytes(s1, 0, len(s1))
[info] 	unfold acc(Bytes(s2, 0, len(s2)), _)
[info] 	if len(s1) > 0 && len(s2) > 0 {
[info] 		// This assertion checks that the memory addresses of the first elements
[info] 		// in s1 and s2 are different. By doing so, we instantiate the triggers in
[info] 		// the quantifier bodies to prove the required inequality for non-empty slices.
[info] 		assert &s1[0] != &s2[0]
[info] 	}
[info] 	fold Bytes(s1, 0, len(s1))
[info] 	fold acc(Bytes(s2, 0, len(s2)), _)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, idx), p)
[info] requires acc(Bytes(s, idx,   end), p)
[info] ensures  acc(Bytes(s, start, end), p)
[info] decreases
[info] func CombineAtIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
[info] 	unfold acc(Bytes(s, start, idx), p)
[info] 	unfold acc(Bytes(s, idx,   end), p)
[info] 	fold   acc(Bytes(s, start, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, idx), p)
[info] requires acc(Bytes(s, idx,   end), p)
[info] ensures  acc(Bytes(s, start, end), p)
[info] decreases
[info] func CombineAtIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
[info] 	unfold acc(Bytes(s, start, idx), p)
[info] 	unfold acc(Bytes(s, idx,   end), p)
[info] 	fold   acc(Bytes(s, start, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, idx), p)
[info] requires acc(Bytes(s, idx,   end), p)
[info] ensures  acc(Bytes(s, start, end), p)
[info] decreases
[info] func CombineAtIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
[info] 	unfold acc(Bytes(s, start, idx), p)
[info] 	unfold acc(Bytes(s, idx,   end), p)
[info] 	fold   acc(Bytes(s, start, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, idx), p)
[info] requires acc(Bytes(s, idx,   end), p)
[info] ensures  acc(Bytes(s, start, end), p)
[info] decreases
[info] func CombineAtIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
[info] 	unfold acc(Bytes(s, start, idx), p)
[info] 	unfold acc(Bytes(s, idx,   end), p)
[info] 	fold   acc(Bytes(s, start, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires acc(Bytes(s, start, idx), p)
[info] requires acc(Bytes(s, idx,   end), p)
[info] ensures  acc(Bytes(s, start, end), p)
[info] decreases
[info] func CombineAtIndex_Bytes(s []byte, start int, end int, idx int, p perm) {
[info] 	unfold acc(Bytes(s, start, idx), p)
[info] 	unfold acc(Bytes(s, idx,   end), p)
[info] 	fold   acc(Bytes(s, start, end), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 < p
[info] requires  len(s1) > 0 || len(s2) > 0
[info] preserves Bytes(s1, 0, len(s1))
[info] preserves acc(Bytes(s2, 0, len(s2)), p)
[info] ensures   s1 !== s2
[info] decreases
[info] func PermsImplyIneq(s1 []byte, s2 []byte, p perm) {
[info] 	unfold Bytes(s1, 0, len(s1))
[info] 	unfold acc(Bytes(s2, 0, len(s2)), p)
[info] 	if len(s1) > 0 && len(s2) > 0 {
[info] 		// This assertion checks that the memory addresses of the first elements
[info] 		// in s1 and s2 are different. By doing so, we instantiate the triggers in
[info] 		// the quantifier bodies to prove the required inequality for non-empty slices.
[info] 		assert &s1[0] != &s2[0]
[info] 	}
[info] 	fold Bytes(s1, 0, len(s1))
[info] 	fold acc(Bytes(s2, 0, len(s2)), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 < p
[info] requires  len(s1) > 0 || len(s2) > 0
[info] preserves Bytes(s1, 0, len(s1))
[info] preserves acc(Bytes(s2, 0, len(s2)), p)
[info] ensures   s1 !== s2
[info] decreases
[info] func PermsImplyIneq(s1 []byte, s2 []byte, p perm) {
[info] 	unfold Bytes(s1, 0, len(s1))
[info] 	unfold acc(Bytes(s2, 0, len(s2)), p)
[info] 	if len(s1) > 0 && len(s2) > 0 {
[info] 		// This assertion checks that the memory addresses of the first elements
[info] 		// in s1 and s2 are different. By doing so, we instantiate the triggers in
[info] 		// the quantifier bodies to prove the required inequality for non-empty slices.
[info] 		assert &s1[0] != &s2[0]
[info] 	}
[info] 	fold Bytes(s1, 0, len(s1))
[info] 	fold acc(Bytes(s2, 0, len(s2)), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 < p
[info] requires  len(s1) > 0 || len(s2) > 0
[info] preserves Bytes(s1, 0, len(s1))
[info] preserves acc(Bytes(s2, 0, len(s2)), p)
[info] ensures   s1 !== s2
[info] decreases
[info] func PermsImplyIneq(s1 []byte, s2 []byte, p perm) {
[info] 	unfold Bytes(s1, 0, len(s1))
[info] 	unfold acc(Bytes(s2, 0, len(s2)), p)
[info] 	if len(s1) > 0 && len(s2) > 0 {
[info] 		// This assertion checks that the memory addresses of the first elements
[info] 		// in s1 and s2 are different. By doing so, we instantiate the triggers in
[info] 		// the quantifier bodies to prove the required inequality for non-empty slices.
[info] 		assert &s1[0] != &s2[0]
[info] 	}
[info] 	fold Bytes(s1, 0, len(s1))
[info] 	fold acc(Bytes(s2, 0, len(s2)), p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to errCtx[i] might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res != nil might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Magic wand instance not found.
[info] Error at: <../VerifiedSCION/pkg/private/serrors/serrors_spec.gobra:46:1> Comparison might panic. 
[info] Both operands of requires  err.ErrorMem()
[info] // The following precondition cannot be adequately captured in Gobra.
[info] // requires forall i int :: 0 <= i && i < len(errCtx) ==> IsOfPrimitiveType(errCtx[i])
[info] preserves forall i int :: { &errCtx[i] } 0 <= i && i < len(errCtx) ==> acc(&errCtx[i], R15)
[info] ensures res != nil && res.ErrorMem()
[info] ensures res.ErrorMem() --* err.ErrorMem()
[info] decreases
[info] func WithCtx(err error, errCtx ...interface{}) (res error) might not have comparable values.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to errCtx[i] might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res != nil might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Magic wand instance not found.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression preserves forall i int :: { &errCtx[i] } 0 <= i && i < len(errCtx) ==> acc(&errCtx[i], R15)
[info] ensures   res != nil && res.ErrorMem()
[info] ensures   res.IsDuplicableMem()
[info] // New always returns a pointer to a basicError, thus it
[info] // only produces comparable values
[info] ensures   isComparable(res)
[info] decreases
[info] func New(msg string, errCtx ...interface{}) (res error) fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to errCtx[i] might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res != nil might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res.IsDuplicableMem() might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion isComparable(res) might not hold.
[info] Error at: <../VerifiedSCION/pkg/private/serrors/serrors_spec.gobra:79:1> Comparison might panic. 
[info] Both operands of requires  cause != nil ==> cause.ErrorMem()
[info] preserves forall i int :: { &errCtx[i] } 0 <= i && i < len(errCtx) ==> acc(&errCtx[i], R15)
[info] // The following precondition cannot be adequately captured in Gobra.
[info] // requires forall i int :: 0 <= i && i < len(errCtx) ==> IsOfPrimitiveType(errCtx[i])
[info] ensures res != nil && res.ErrorMem()
[info] ensures cause != nil ==> (res.ErrorMem() --* cause.ErrorMem())
[info] decreases
[info] func WrapStr(msg string, cause error, errCtx ...interface{}) (res error) might not have comparable values.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to errCtx[i] might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res != nil might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Magic wand instance not found.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to errCtx[i] might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion res != nil might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Magic wand instance not found.
[info] Error at: <../VerifiedSCION/verification/dependencies/errors/errors_spec.gobra:15:1> Comparison might panic. 
[info] Both operands of requires  err.ErrorMem()
[info] ensures   res.ErrorMem()
[info] ensures   res.ErrorMem() --* err.ErrorMem()
[info] decreases err.ErrorMem()
[info] func Unwrap(err error) (res error) might not have comparable values.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= len(s)
[info] requires acc(Bytes(s[start:end], 0, end-start), p)
[info] requires acc(Bytes(s, 0, start), p)
[info] requires acc(Bytes(s, end, len(s)), p)
[info] ensures  acc(Bytes(s, 0, len(s)), p)
[info] decreases
[info] func CombineRange_Bytes(s []byte, start int, end int, p perm) {
[info] 	Unslice_Bytes(s, start, end, p)
[info] 	CombineAtIndex_Bytes(s, start, len(s), end, p)
[info] 	CombineAtIndex_Bytes(s, 0, len(s), start, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= len(s)
[info] requires acc(Bytes(s[start:end], 0, end-start), p)
[info] requires acc(Bytes(s, 0, start), p)
[info] requires acc(Bytes(s, end, len(s)), p)
[info] ensures  acc(Bytes(s, 0, len(s)), p)
[info] decreases
[info] func CombineRange_Bytes(s []byte, start int, end int, p perm) {
[info] 	Unslice_Bytes(s, start, end, p)
[info] 	CombineAtIndex_Bytes(s, start, len(s), end, p)
[info] 	CombineAtIndex_Bytes(s, 0, len(s), start, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= len(s)
[info] requires acc(Bytes(s[start:end], 0, end-start), p)
[info] requires acc(Bytes(s, 0, start), p)
[info] requires acc(Bytes(s, end, len(s)), p)
[info] ensures  acc(Bytes(s, 0, len(s)), p)
[info] decreases
[info] func CombineRange_Bytes(s []byte, start int, end int, p perm) {
[info] 	Unslice_Bytes(s, start, end, p)
[info] 	CombineAtIndex_Bytes(s, start, len(s), end, p)
[info] 	CombineAtIndex_Bytes(s, 0, len(s), start, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires 0 <= start && start <= end && end <= len(s)
[info] requires acc(Bytes(s[start:end], 0, end-start), p)
[info] requires acc(Bytes(s, 0, start), p)
[info] requires acc(Bytes(s, end, len(s)), p)
[info] ensures  acc(Bytes(s, 0, len(s)), p)
[info] decreases
[info] func CombineRange_Bytes(s []byte, start int, end int, p perm) {
[info] 	Unslice_Bytes(s, start, end, p)
[info] 	CombineAtIndex_Bytes(s, start, len(s), end, p)
[info] 	CombineAtIndex_Bytes(s, 0, len(s), start, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to err.ErrorMem() might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion target != nil might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion target != nil might not hold.
[info] Error at: <../VerifiedSCION/pkg/private/serrors/serrors_spec.gobra:63:1> Comparison might panic. 
[info] Both operands of requires  msg.ErrorMem() && cause.ErrorMem()
[info] preserves forall i int :: { &errCtx[i] } 0 <= i && i < len(errCtx) ==> acc(&errCtx[i], R15)
[info] // The following precondition cannot be adequately captured in Gobra.
[info] // requires forall i int :: 0 <= i && i < len(errCtx) ==> IsOfPrimitiveType(errCtx[i])
[info] ensures   res != nil && res.ErrorMem()
[info] ensures   res.ErrorMem() --* (msg.ErrorMem() && cause.ErrorMem())
[info] decreases
[info] func Wrap(msg, cause error, errCtx ...interface{}) (res error) might not have comparable values.
[info] Error at: <../VerifiedSCION/verification/dependencies/errors/errors_spec.gobra:47:1> Comparison might panic. 
[info] Both operands of requires  err    != nil ==> err.ErrorMem()
[info] requires  target != nil
[info] preserves target.Mem()
[info] ensures   res ==> (
[info] 	let nestedErr := target.Get() in
[info] 	err != nil               &&
[info] 	nestedErr != nil         &&
[info] 	nestedErr.ErrorMem()     &&
[info] 	target.CanSet(nestedErr) &&
[info] 	(nestedErr.ErrorMem() --* err.ErrorMem()))
[info] ensures   !res ==> err.ErrorMem()
[info] decreases err.ErrorMem()
[info] func As(err error, target ErrorCell) (res bool) might not have comparable values.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion nestedErr != nil might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to err.ErrorMem() might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion err != nil might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to err.ErrorMem() might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currINF might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion InfoFieldOffset(currINF, headerOffset) < len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currINF might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion InfoFieldOffset(currINF, headerOffset) < len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func ConsDir(raw []byte, currINF int, headerOffset int) bool {
[info] 	return unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		raw[InfoFieldOffset(currINF, headerOffset)] & 0x1 == 0x1
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func Peer(raw []byte, currINF int, headerOffset int) bool {
[info] 	return unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		raw[InfoFieldOffset(currINF, headerOffset)] & 0x2 == 0x2
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func ConsDir(raw []byte, currINF int, headerOffset int) bool {
[info] 	return unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		raw[InfoFieldOffset(currINF, headerOffset)] & 0x1 == 0x1
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func ConsDir(raw []byte, currINF int, headerOffset int) bool {
[info] 	return unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		raw[InfoFieldOffset(currINF, headerOffset)] & 0x1 == 0x1
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func Peer(raw []byte, currINF int, headerOffset int) bool {
[info] 	return unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		raw[InfoFieldOffset(currINF, headerOffset)] & 0x2 == 0x2
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func Peer(raw []byte, currINF int, headerOffset int) bool {
[info] 	return unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		raw[InfoFieldOffset(currINF, headerOffset)] & 0x2 == 0x2
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func Timestamp(raw []byte, currINF int, headerOffset int) io.Ainfo {
[info] 	return let idx := InfoFieldOffset(currINF, headerOffset)+4 in
[info] 		unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		let _ := sl.AssertSliceOverlap(raw, idx, idx+4) in
[info] 		io.Ainfo{uint(binary.BigEndian.Uint32(raw[idx:idx+4]))}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func Timestamp(raw []byte, currINF int, headerOffset int) io.Ainfo {
[info] 	return let idx := InfoFieldOffset(currINF, headerOffset)+4 in
[info] 		unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		let _ := sl.AssertSliceOverlap(raw, idx, idx+4) in
[info] 		io.Ainfo{uint(binary.BigEndian.Uint32(raw[idx:idx+4]))}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func Timestamp(raw []byte, currINF int, headerOffset int) io.Ainfo {
[info] 	return let idx := InfoFieldOffset(currINF, headerOffset)+4 in
[info] 		unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		let _ := sl.AssertSliceOverlap(raw, idx, idx+4) in
[info] 		io.Ainfo{uint(binary.BigEndian.Uint32(raw[idx:idx+4]))}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currINF might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= middle might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion middle+InfoLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= currINF might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= headerOffset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires 0 <= middle
[info] requires middle+InfoLen <= len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func BytesToAbsInfoField(raw [] byte, middle int) (io.AbsInfoField) {
[info] 	return unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		BytesToAbsInfoFieldHelper(raw, middle)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression opaque
[info] requires 0 <= middle
[info] requires middle+InfoLen <= len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func BytesToAbsInfoField(raw [] byte, middle int) (io.AbsInfoField) {
[info] 	return unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		BytesToAbsInfoFieldHelper(raw, middle)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func AbsUinfo(raw []byte, currINF int, headerOffset int) set[io.MsgTerm] {
[info] 	return let idx := InfoFieldOffset(currINF, headerOffset)+2 in
[info] 		unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		let _ := sl.AssertSliceOverlap(raw, idx, idx+2) in
[info] 		AbsUInfoFromUint16(binary.BigEndian.Uint16(raw[idx:idx+2]))
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func AbsUinfo(raw []byte, currINF int, headerOffset int) set[io.MsgTerm] {
[info] 	return let idx := InfoFieldOffset(currINF, headerOffset)+2 in
[info] 		unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		let _ := sl.AssertSliceOverlap(raw, idx, idx+2) in
[info] 		AbsUInfoFromUint16(binary.BigEndian.Uint16(raw[idx:idx+2]))
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= currINF && 0 <= headerOffset
[info] requires InfoFieldOffset(currINF, headerOffset) + InfoLen < len(raw)
[info] requires sl.Bytes(raw, 0, len(raw))
[info] decreases
[info] pure func AbsUinfo(raw []byte, currINF int, headerOffset int) set[io.MsgTerm] {
[info] 	return let idx := InfoFieldOffset(currINF, headerOffset)+2 in
[info] 		unfolding sl.Bytes(raw, 0, len(raw)) in
[info] 		let _ := sl.AssertSliceOverlap(raw, idx, idx+2) in
[info] 		AbsUInfoFromUint16(binary.BigEndian.Uint16(raw[idx:idx+2]))
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= middle
[info] requires middle+InfoLen <= len(raw)
[info] requires forall i int :: { &raw[i] } middle <= i && i < len(raw) ==>
[info] 	acc(&raw[i])
[info] decreases
[info] pure func BytesToAbsInfoFieldHelper(raw [] byte, middle int) (io.AbsInfoField) {
[info] 	return let _ := sl.AssertSliceOverlap(raw, middle+2, middle+4) in
[info] 		let _ := sl.AssertSliceOverlap(raw, middle+4, middle+8) in
[info] 		io.AbsInfoField {
[info] 			AInfo: io.Ainfo{uint(binary.BigEndian.Uint32(raw[middle+4:middle+8]))},
[info] 			UInfo: AbsUInfoFromUint16(binary.BigEndian.Uint16(raw[middle+2:middle+4])),
[info] 			ConsDir: raw[middle] & 0x1 == 0x1,
[info] 			Peer: raw[middle] & 0x2  == 0x2,
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= middle
[info] requires middle+InfoLen <= len(raw)
[info] requires forall i int :: { &raw[i] } middle <= i && i < len(raw) ==>
[info] 	acc(&raw[i])
[info] decreases
[info] pure func BytesToAbsInfoFieldHelper(raw [] byte, middle int) (io.AbsInfoField) {
[info] 	return let _ := sl.AssertSliceOverlap(raw, middle+2, middle+4) in
[info] 		let _ := sl.AssertSliceOverlap(raw, middle+4, middle+8) in
[info] 		io.AbsInfoField {
[info] 			AInfo: io.Ainfo{uint(binary.BigEndian.Uint32(raw[middle+4:middle+8]))},
[info] 			UInfo: AbsUInfoFromUint16(binary.BigEndian.Uint16(raw[middle+2:middle+4])),
[info] 			ConsDir: raw[middle] & 0x1 == 0x1,
[info] 			Peer: raw[middle] & 0x2  == 0x2,
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= middle might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion middle+InfoLen <= len(raw) might not hold.
[info] Error at: <../VerifiedSCION/verification/dependencies/errors/errors_spec.gobra:28:1> Comparison might panic. 
[info] Both operands of preserves err    != nil ==> err.ErrorMem()
[info] preserves target != nil ==> target.ErrorMem()
[info] ensures   res && target != nil ==> err != nil
[info] decreases err.ErrorMem()
[info] func Is(err, target error) (res bool) might not have comparable values.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= middle might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion middle+InfoLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to raw[i] might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= t && t < maxPathType
[info] requires PkgMem()
[info] decreases
[info] pure func GetType(t Type) (res Metadata) {
[info] 	return unfolding PkgMem() in
[info] 		registeredPaths[t].Metadata
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= t && t < maxPathType
[info] requires PkgMem()
[info] decreases
[info] pure func Registered(t Type) (res bool) {
[info] 	return unfolding PkgMem() in
[info] 		registeredPaths[t].inUse
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= t might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion t < maxPathType might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion p != nil might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= t might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion t < maxPathType might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= middle
[info] requires  middle+InfoLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R55)
[info] preserves acc(sl.Bytes(raw[middle:middle+InfoLen], 0, InfoLen), R55)
[info] ensures   BytesToAbsInfoField(raw, middle) ==
[info] 	BytesToAbsInfoField(raw[middle:middle+InfoLen], 0)
[info] decreases
[info] func BytesToAbsInfoFieldOffsetEq(raw [] byte, middle int) {
[info] 	start := middle
[info] 	end := middle+InfoLen
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(raw[start:end], 0, InfoLen), R56)
[info] 	absInfo1 := reveal BytesToAbsInfoField(raw, start)
[info] 	absInfo2 := reveal BytesToAbsInfoField(raw[start:end], 0)
[info] 	assert absInfo1.ConsDir == absInfo2.ConsDir
[info] 	assert absInfo1.Peer == absInfo2.Peer
[info] 	sl.AssertSliceOverlap(raw, start, end)
[info] 	sl.AssertSliceOverlap(raw[start:end], 4, 8)
[info] 	assert absInfo1.AInfo == absInfo2.AInfo
[info] 	sl.AssertSliceOverlap(raw[start:end], 2, 4)
[info] 	assert absInfo1.UInfo == absInfo2.UInfo
[info] 	assert absInfo1 == absInfo2
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(raw[start:end], 0, InfoLen), R56)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= middle
[info] requires  middle+InfoLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R55)
[info] preserves acc(sl.Bytes(raw[middle:middle+InfoLen], 0, InfoLen), R55)
[info] ensures   BytesToAbsInfoField(raw, middle) ==
[info] 	BytesToAbsInfoField(raw[middle:middle+InfoLen], 0)
[info] decreases
[info] func BytesToAbsInfoFieldOffsetEq(raw [] byte, middle int) {
[info] 	start := middle
[info] 	end := middle+InfoLen
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(raw[start:end], 0, InfoLen), R56)
[info] 	absInfo1 := reveal BytesToAbsInfoField(raw, start)
[info] 	absInfo2 := reveal BytesToAbsInfoField(raw[start:end], 0)
[info] 	assert absInfo1.ConsDir == absInfo2.ConsDir
[info] 	assert absInfo1.Peer == absInfo2.Peer
[info] 	sl.AssertSliceOverlap(raw, start, end)
[info] 	sl.AssertSliceOverlap(raw[start:end], 4, 8)
[info] 	assert absInfo1.AInfo == absInfo2.AInfo
[info] 	sl.AssertSliceOverlap(raw[start:end], 2, 4)
[info] 	assert absInfo1.UInfo == absInfo2.UInfo
[info] 	assert absInfo1 == absInfo2
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(raw[start:end], 0, InfoLen), R56)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= middle might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion middle + HopLen <= end might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion end <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= start might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion start <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset + HopLen <= end might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion end <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= offset might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion offset+HopLen <= len(raw) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= start && start <= middle
[info] requires middle + HopLen <= end && end <= len(raw)
[info] requires sl.Bytes(raw, start, end)
[info] decreases
[info] pure func BytesToIO_HF(raw [] byte, start int, middle int, end int) (io.HF) {
[info] 	return let _ := sl.AssertSliceOverlap(raw, middle+2, middle+4)     in
[info] 		let _ := sl.AssertSliceOverlap(raw, middle+4, middle+6)        in
[info] 		let _ := sl.AssertSliceOverlap(raw, middle+6, middle+6+MacLen) in
[info] 		unfolding sl.Bytes(raw, start, end)                            in
[info] 		let inif2 := binary.BigEndian.Uint16(raw[middle+2:middle+4])   in
[info] 		let egif2 := binary.BigEndian.Uint16(raw[middle+4:middle+6])   in
[info] 		let op_inif2 := ifsToIO_ifs(inif2)                             in
[info] 		let op_egif2 := ifsToIO_ifs(egif2)                             in
[info] 		io.HF {
[info] 			InIF2: op_inif2,
[info] 			EgIF2: op_egif2,
[info] 			HVF: AbsMac(FromSliceToMacArray(raw[middle+6:middle+6+MacLen])),
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= start && start <= middle
[info] requires middle + HopLen <= end && end <= len(raw)
[info] requires sl.Bytes(raw, start, end)
[info] decreases
[info] pure func BytesToIO_HF(raw [] byte, start int, middle int, end int) (io.HF) {
[info] 	return let _ := sl.AssertSliceOverlap(raw, middle+2, middle+4)     in
[info] 		let _ := sl.AssertSliceOverlap(raw, middle+4, middle+6)        in
[info] 		let _ := sl.AssertSliceOverlap(raw, middle+6, middle+6+MacLen) in
[info] 		unfolding sl.Bytes(raw, start, end)                            in
[info] 		let inif2 := binary.BigEndian.Uint16(raw[middle+2:middle+4])   in
[info] 		let egif2 := binary.BigEndian.Uint16(raw[middle+4:middle+6])   in
[info] 		let op_inif2 := ifsToIO_ifs(inif2)                             in
[info] 		let op_egif2 := ifsToIO_ifs(egif2)                             in
[info] 		io.HF {
[info] 			InIF2: op_inif2,
[info] 			EgIF2: op_egif2,
[info] 			HVF: AbsMac(FromSliceToMacArray(raw[middle+6:middle+6+MacLen])),
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= start && start <= middle
[info] requires middle + HopLen <= end && end <= len(raw)
[info] requires sl.Bytes(raw, start, end)
[info] decreases
[info] pure func BytesToIO_HF(raw [] byte, start int, middle int, end int) (io.HF) {
[info] 	return let _ := sl.AssertSliceOverlap(raw, middle+2, middle+4)     in
[info] 		let _ := sl.AssertSliceOverlap(raw, middle+4, middle+6)        in
[info] 		let _ := sl.AssertSliceOverlap(raw, middle+6, middle+6+MacLen) in
[info] 		unfolding sl.Bytes(raw, start, end)                            in
[info] 		let inif2 := binary.BigEndian.Uint16(raw[middle+2:middle+4])   in
[info] 		let egif2 := binary.BigEndian.Uint16(raw[middle+4:middle+6])   in
[info] 		let op_inif2 := ifsToIO_ifs(inif2)                             in
[info] 		let op_egif2 := ifsToIO_ifs(egif2)                             in
[info] 		io.HF {
[info] 			InIF2: op_inif2,
[info] 			EgIF2: op_egif2,
[info] 			HVF: AbsMac(FromSliceToMacArray(raw[middle+6:middle+6+MacLen])),
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= start && start <= middle
[info] requires middle + HopLen <= end && end <= len(raw)
[info] requires sl.Bytes(raw, start, end)
[info] decreases
[info] pure func BytesToIO_HF(raw [] byte, start int, middle int, end int) (io.HF) {
[info] 	return let _ := sl.AssertSliceOverlap(raw, middle+2, middle+4)     in
[info] 		let _ := sl.AssertSliceOverlap(raw, middle+4, middle+6)        in
[info] 		let _ := sl.AssertSliceOverlap(raw, middle+6, middle+6+MacLen) in
[info] 		unfolding sl.Bytes(raw, start, end)                            in
[info] 		let inif2 := binary.BigEndian.Uint16(raw[middle+2:middle+4])   in
[info] 		let egif2 := binary.BigEndian.Uint16(raw[middle+4:middle+6])   in
[info] 		let op_inif2 := ifsToIO_ifs(inif2)                             in
[info] 		let op_egif2 := ifsToIO_ifs(egif2)                             in
[info] 		io.HF {
[info] 			InIF2: op_inif2,
[info] 			EgIF2: op_egif2,
[info] 			HVF: AbsMac(FromSliceToMacArray(raw[middle+6:middle+6+MacLen])),
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  len(buffer) >= MACBufferSize
[info] preserves sl.Bytes(buffer, 0, len(buffer))
[info] decreases
[info] func MACInput(segID uint16, timestamp uint32, expTime uint8,
[info] 	consIngress, consEgress uint16, buffer []byte) {
[info] 	unfold sl.Bytes(buffer, 0, len(buffer))
[info] 	assert &buffer[0:2][0] == &buffer[0] && &buffer[0:2][1] == &buffer[1]
[info] 	binary.BigEndian.PutUint16(buffer[0:2], 0)
[info] 	assert &buffer[2:4][0] == &buffer[2] && &buffer[2:4][1] == &buffer[3]
[info] 	binary.BigEndian.PutUint16(buffer[2:4], segID)
[info] 	assert &buffer[4:8][0] == &buffer[4] && &buffer[4:8][1] == &buffer[5]
[info] 	assert &buffer[4:8][2] == &buffer[6] && &buffer[4:8][3] == &buffer[7]
[info] 	binary.BigEndian.PutUint32(buffer[4:8], timestamp)
[info] 	buffer[8] = 0
[info] 	buffer[9] = expTime
[info] 	assert &buffer[10:12][0] == &buffer[10] && &buffer[10:12][1] == &buffer[11]
[info] 	binary.BigEndian.PutUint16(buffer[10:12], consIngress)
[info] 	assert &buffer[12:14][0] == &buffer[12] && &buffer[12:14][1] == &buffer[13]
[info] 	binary.BigEndian.PutUint16(buffer[12:14], consEgress)
[info] 	assert &buffer[14:16][0] == &buffer[14] && &buffer[14:16][1] == &buffer[15]
[info] 	binary.BigEndian.PutUint16(buffer[14:16], 0)
[info] 	fold sl.Bytes(buffer, 0, len(buffer))
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to sl.Bytes(buffer, 0, len(buffer)) might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(res) == MACBufferSize might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(res) == MACBufferSize might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires MacLen <= len(mac)
[info] requires forall i int :: { &mac[i] } 0 <= i && i < MacLen ==> acc(&mac[i])
[info] ensures  len(res) == MacLen
[info] ensures  forall i int :: { res[i] } 0 <= i && i < MacLen ==> mac[i] == res[i]
[info] decreases
[info] pure func FromSliceToMacArray(mac []byte) (res [MacLen]byte) {
[info] 	return [MacLen]byte{ mac[0], mac[1], mac[2], mac[3], mac[4], mac[5] }
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion MacLen <= len(mac) might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to mac[i] might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  offset+HopLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R55)
[info] preserves acc(sl.Bytes(raw[offset:offset+HopLen], 0, HopLen), R55)
[info] ensures   BytesToIO_HF(raw, 0, offset, len(raw)) ==
[info] 	BytesToIO_HF(raw[offset:offset+HopLen], 0, 0, HopLen)
[info] decreases
[info] func BytesToAbsHopFieldOffsetEq(raw [] byte, offset int) {
[info] 	WidenBytesHopField(raw, offset, offset, offset+HopLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= offset
[info] requires  offset+HopLen <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R55)
[info] preserves acc(sl.Bytes(raw[offset:offset+HopLen], 0, HopLen), R55)
[info] ensures   BytesToIO_HF(raw, 0, offset, len(raw)) ==
[info] 	BytesToIO_HF(raw[offset:offset+HopLen], 0, 0, HopLen)
[info] decreases
[info] func BytesToAbsHopFieldOffsetEq(raw [] byte, offset int) {
[info] 	WidenBytesHopField(raw, offset, offset, offset+HopLen)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion forall i int :: { res[i] } 0 <= i && i < MacLen ==> mac[i] == res[i] might not hold.
[info] Error at: <../VerifiedSCION/pkg/slayers/path/mac.go:49:1> Comparison might panic. 
[info] Both operands of requires  h != nil && h.Mem()
[info] preserves len(buffer) >= MACBufferSize ==> sl.Bytes(buffer, 0, len(buffer))
[info] ensures   h.Mem()
[info] ensures   len(res) == MACBufferSize && sl.Bytes(res, 0, MACBufferSize)
[info] decreases
[info] func FullMAC(h hash.Hash, info InfoField, hf HopField, buffer []byte) (res []byte) {
[info] 	if len(buffer) < MACBufferSize {
[info] 		buffer = make([]byte, MACBufferSize)
[info] 		fold sl.Bytes(buffer, 0, len(buffer))
[info] 	}
[info] 	h.Reset()
[info] 	MACInput(info.SegID, info.Timestamp, hf.ExpTime,
[info] 		hf.ConsIngress, hf.ConsEgress, buffer)
[info] 	unfold sl.Bytes(buffer, 0, len(buffer))
[info] 	defer fold sl.Bytes(buffer, 0, len(buffer))
[info] 	// Write must not return an error: https://godoc.org/hash#Hash
[info] 	if _, err := h.Write(buffer); err != nil {
[info] 		Unreachable()
[info] 		panic(err)
[info] 	}
[info] 	assert h.Size() >= 16
[info] 	res = h.Sum(buffer[:0])[:16]
[info] 	fold sl.Bytes(res, 0, MACBufferSize)
[info] 	return res
[info] } might not have comparable values.
[info] Error at: <../VerifiedSCION/pkg/slayers/path/mac.go:32:1> Comparison might panic. 
[info] Both operands of requires  h != nil && h.Mem()
[info] preserves len(buffer) >= MACBufferSize ==> sl.Bytes(buffer, 0, len(buffer))
[info] ensures   h.Mem()
[info] decreases
[info] func MAC(h hash.Hash, info InfoField, hf HopField, buffer []byte) [MacLen]byte {
[info] 	mac := FullMAC(h, info, hf, buffer)
[info] 	var res  @  [MacLen]byte
[info] 	unfold sl.Bytes(mac, 0, MACBufferSize)
[info] 	copy(res[:], mac[:MacLen] , R1 )
[info] 	return res
[info] } might not have comparable values.
[info] Error at: <../VerifiedSCION/pkg/slayers/path/io_msgterm_spec.gobra:51:1> Linter Check Failed. 
[info] Permission to mac1[i] might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion len(mac1) == MacLen might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to mac1[i] might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> mac1[i] == mac2[i] might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= pathMeta.Type might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion pathMeta.Type < maxPathType might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion pathMeta.New implements NewPathSpec might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= offset
[info] requires  offset + HopLen <= end
[info] requires  end <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R55)
[info] preserves acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R55)
[info] ensures   BytesToIO_HF(raw, 0, offset, len(raw)) ==
[info] 	BytesToIO_HF(raw[start:end], 0, offset-start, end-start)
[info] decreases
[info] func WidenBytesHopField(raw []byte, offset int, start int, end int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R56)
[info] 	hfBytes1 := BytesToIO_HF(raw, 0, offset, len(raw))
[info] 	hfBytes2 := BytesToIO_HF(raw[start:end], 0, offset-start, end-start)
[info] 	sl.AssertSliceOverlap(raw, start, end)
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+2, offset-start+4)
[info] 	assert hfBytes1.InIF2 == hfBytes2.InIF2
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+4, offset-start+6)
[info] 	assert hfBytes1.EgIF2 == hfBytes2.EgIF2
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+6, offset-start+6+MacLen)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R56)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= offset
[info] requires  offset + HopLen <= end
[info] requires  end <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R55)
[info] preserves acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R55)
[info] ensures   BytesToIO_HF(raw, 0, offset, len(raw)) ==
[info] 	BytesToIO_HF(raw[start:end], 0, offset-start, end-start)
[info] decreases
[info] func WidenBytesHopField(raw []byte, offset int, start int, end int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R56)
[info] 	hfBytes1 := BytesToIO_HF(raw, 0, offset, len(raw))
[info] 	hfBytes2 := BytesToIO_HF(raw[start:end], 0, offset-start, end-start)
[info] 	sl.AssertSliceOverlap(raw, start, end)
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+2, offset-start+4)
[info] 	assert hfBytes1.InIF2 == hfBytes2.InIF2
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+4, offset-start+6)
[info] 	assert hfBytes1.EgIF2 == hfBytes2.EgIF2
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+6, offset-start+6+MacLen)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R56)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= offset
[info] requires  offset + HopLen <= end
[info] requires  end <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R55)
[info] preserves acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R55)
[info] ensures   BytesToIO_HF(raw, 0, offset, len(raw)) ==
[info] 	BytesToIO_HF(raw[start:end], 0, offset-start, end-start)
[info] decreases
[info] func WidenBytesHopField(raw []byte, offset int, start int, end int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R56)
[info] 	hfBytes1 := BytesToIO_HF(raw, 0, offset, len(raw))
[info] 	hfBytes2 := BytesToIO_HF(raw[start:end], 0, offset-start, end-start)
[info] 	sl.AssertSliceOverlap(raw, start, end)
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+2, offset-start+4)
[info] 	assert hfBytes1.InIF2 == hfBytes2.InIF2
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+4, offset-start+6)
[info] 	assert hfBytes1.EgIF2 == hfBytes2.EgIF2
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+6, offset-start+6+MacLen)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R56)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires  0 <= start && start <= offset
[info] requires  offset + HopLen <= end
[info] requires  end <= len(raw)
[info] preserves acc(sl.Bytes(raw, 0, len(raw)), R55)
[info] preserves acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R55)
[info] ensures   BytesToIO_HF(raw, 0, offset, len(raw)) ==
[info] 	BytesToIO_HF(raw[start:end], 0, offset-start, end-start)
[info] decreases
[info] func WidenBytesHopField(raw []byte, offset int, start int, end int) {
[info] 	unfold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	unfold acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R56)
[info] 	hfBytes1 := BytesToIO_HF(raw, 0, offset, len(raw))
[info] 	hfBytes2 := BytesToIO_HF(raw[start:end], 0, offset-start, end-start)
[info] 	sl.AssertSliceOverlap(raw, start, end)
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+2, offset-start+4)
[info] 	assert hfBytes1.InIF2 == hfBytes2.InIF2
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+4, offset-start+6)
[info] 	assert hfBytes1.EgIF2 == hfBytes2.EgIF2
[info] 	sl.AssertSliceOverlap(raw[start:end], offset-start+6, offset-start+6+MacLen)
[info] 	fold acc(sl.Bytes(raw, 0, len(raw)), R56)
[info] 	fold acc(sl.Bytes(raw[start:end], 0, len(raw[start:end])), R56)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= pathType && pathType < maxPathType
[info] requires acc(PkgMem(), _)
[info] ensures  e != nil ==> e.ErrorMem()
[info] ensures  e == nil ==> p != nil && p.NonInitMem()
[info] decreases
[info] func NewPath(pathType Type) (p Path, e error) {
[info] 	unfold acc(PkgMem(), _)
[info] 	pm := registeredPaths[pathType]
[info] 	if !pm.inUse {
[info] 		if strictDecoding {
[info] 			return nil, serrors.New("unsupported path", "type", uint8(pathType))
[info] 		}
[info] 		tmp := &rawPath{}
[info] 		fold tmp.NonInitMem()
[info] 		return tmp, nil
[info] 	}
[info] 	return pm.New()  as NewPathSpec , nil
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires len(mac1) == MacLen
[info] requires forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> acc(&mac1[i], R50)
[info] requires forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> mac1[i] == mac2[i]
[info] ensures  forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> acc(&mac1[i], R50)
[info] ensures  AbsMac(FromSliceToMacArray(mac1)) == AbsMac(mac2)
[info] decreases
[info] func EqualBytesImplyEqualMac(mac1 []byte, mac2 [MacLen]byte) {
[info] 	mac1Arr := FromSliceToMacArray(mac1)
[info] 	assert mac1Arr == mac2
[info] 	assert mac1Arr[0] == mac2[0] &&
[info] 		mac1Arr[1] == mac2[1]    &&
[info] 		mac1Arr[2] == mac2[2]    &&
[info] 		mac1Arr[3] == mac2[3]    &&
[info] 		mac1Arr[4] == mac2[4]    &&
[info] 		mac1Arr[5] == mac2[5]
[info] 	assert len(mac1Arr) == len(mac2)
[info] 	AbsMacArrayCongruence(mac1Arr, mac2)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires len(mac1) == MacLen
[info] requires forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> acc(&mac1[i], R50)
[info] requires forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> mac1[i] == mac2[i]
[info] ensures  forall i int :: { &mac1[i] } 0 <= i && i < MacLen ==> acc(&mac1[i], R50)
[info] ensures  AbsMac(FromSliceToMacArray(mac1)) == AbsMac(mac2)
[info] decreases
[info] func EqualBytesImplyEqualMac(mac1 []byte, mac2 [MacLen]byte) {
[info] 	mac1Arr := FromSliceToMacArray(mac1)
[info] 	assert mac1Arr == mac2
[info] 	assert mac1Arr[0] == mac2[0] &&
[info] 		mac1Arr[1] == mac2[1]    &&
[info] 		mac1Arr[2] == mac2[2]    &&
[info] 		mac1Arr[3] == mac2[3]    &&
[info] 		mac1Arr[4] == mac2[4]    &&
[info] 		mac1Arr[5] == mac2[5]
[info] 	assert len(mac1Arr) == len(mac2)
[info] 	AbsMacArrayCongruence(mac1Arr, mac2)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 <= pathMeta.Type && pathMeta.Type < maxPathType
[info] requires PkgMem()
[info] requires RegisteredTypes().DoesNotContain(int64(pathMeta.Type))
[info] requires pathMeta.New implements NewPathSpec
[info] ensures  PkgMem()
[info] ensures  RegisteredTypes().Contains(int64(pathMeta.Type))
[info] decreases
[info] func RegisterPath(pathMeta Metadata) {
[info] 	unfold PkgMem()
[info] 	pm := registeredPaths[pathMeta.Type]
[info] 	RegisteredTypes().DoesNotContainImpliesNotFContains(int64(pathMeta.Type))
[info] 	if pm.inUse {
[info] 		panic("path type already registered")
[info] 	}
[info] 	RegisteredTypes().Add(int64(pathMeta.Type))
[info] 	registeredPaths[pathMeta.Type].inUse = true
[info] 	registeredPaths[pathMeta.Type].Metadata = pathMeta
[info] 	RegisteredTypes().ContainsImpliesFContains(int64(pathMeta.Type))
[info] 	fold PkgMem()
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion p != nil might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion 0 <= pathType might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion pathType < maxPathType might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires mac1 == mac2
[info] ensures  AbsMac(mac1) == AbsMac(mac2)
[info] decreases
[info] func AbsMacArrayCongruence(mac1 [MacLen]byte, mac2 [MacLen]byte) fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires mac1 == mac2
[info] ensures  AbsMac(mac1) == AbsMac(mac2)
[info] decreases
[info] func AbsMacArrayCongruence(mac1 [MacLen]byte, mac2 [MacLen]byte) fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires CBioIO_bio3s_recv(t)
[info] decreases
[info] pure func dp3s_iospec_bio3s_recv_T(t Place) Place fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to e.ErrorMem() might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion p != nil might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Permission to p.NonInitMem() might not suffice.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires CBio_IN_bio3s_xover(t, v)
[info] decreases
[info] pure func dp3s_iospec_bio3s_xover_T(t Place, v Val) Place fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires CBio_IN_bio3s_xover(t, v)
[info] decreases
[info] pure func dp3s_iospec_bio3s_xover_T(t Place, v Val) Place fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires CBio_IN_bio3s_enter(t, v)
[info] decreases
[info] pure func CBio_IN_bio3s_enter_T(t Place, v Val) Place fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires CBio_IN_bio3s_enter(t, v)
[info] decreases
[info] pure func CBio_IN_bio3s_enter_T(t Place, v Val) Place fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires CBio_IN_bio3s_exit(t, v)
[info] decreases
[info] pure func dp3s_iospec_bio3s_exit_T(t Place, v Val) Place fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires CBio_IN_bio3s_exit(t, v)
[info] decreases
[info] pure func dp3s_iospec_bio3s_exit_T(t Place, v Val) Place fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires CBioIO_bio3s_send(t, v)
[info] decreases
[info] pure func dp3s_iospec_bio3s_send_T(t Place, v Val) Place fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires CBioIO_bio3s_send(t, v)
[info] decreases
[info] pure func dp3s_iospec_bio3s_send_T(t Place, v Val) Place fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires CBioIO_bio3s_recv(t)
[info] ensures val.isValPkt || val.isValUnsupported
[info] decreases
[info] pure func dp3s_iospec_bio3s_recv_R(t Place) (val Val) fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires CBio_Skip(t)
[info] decreases
[info] pure func dp3s_iospec_skip_T(t Place) Place fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression decreases
[info] requires token(t) && CBio_IN_bio3s_enter(t, v)
[info] ensures  token(old(CBio_IN_bio3s_enter_T(t, v)))
[info] func Enter(ghost t Place, ghost v Val) fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression decreases
[info] requires token(t) && CBio_IN_bio3s_enter(t, v)
[info] ensures  token(old(CBio_IN_bio3s_enter_T(t, v)))
[info] func Enter(ghost t Place, ghost v Val) fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression decreases
[info] requires token(t) && CBio_IN_bio3s_xover(t, v)
[info] ensures  token(old(dp3s_iospec_bio3s_xover_T(t, v)))
[info] func Xover(ghost t Place, ghost v Val) fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression decreases
[info] requires token(t) && CBio_IN_bio3s_xover(t, v)
[info] ensures  token(old(dp3s_iospec_bio3s_xover_T(t, v)))
[info] func Xover(ghost t Place, ghost v Val) fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression decreases
[info] requires token(t) && CBio_IN_bio3s_exit(t, v)
[info] ensures  token(old(dp3s_iospec_bio3s_exit_T(t, v)))
[info] func Exit(ghost t Place, ghost v Val) fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression decreases
[info] requires token(t) && CBio_IN_bio3s_exit(t, v)
[info] ensures  token(old(dp3s_iospec_bio3s_exit_T(t, v)))
[info] func Exit(ghost t Place, ghost v Val) fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires len(currseg.Future) > 0
[info] decreases
[info] pure func establishGuardTraversedsegInc(currseg Seg, direction bool) Seg {
[info] 	return let uinfo := direction ?
[info] 		upd_uinfo(currseg.UInfo, currseg.Future[0]) :
[info] 		currseg.UInfo in
[info] 		Seg {
[info] 			AInfo: currseg.AInfo,
[info] 			UInfo: uinfo,
[info] 			ConsDir: currseg.ConsDir,
[info] 			Peer: currseg.Peer,
[info] 			Past: seq[HF]{currseg.Future[0]} ++ currseg.Past,
[info] 			Future: currseg.Future[1:],
[info] 			History: seq[AHI]{currseg.Future[0].Toab()} ++ currseg.History,
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Assertion p > 0 might not hold.
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires len(currseg.Future) > 0
[info] decreases
[info] pure func establishGuardTraversedseg(currseg Seg, direction bool) Seg {
[info] 	return let uinfo := direction ?
[info] 		upd_uinfo(currseg.UInfo, currseg.Future[0]) :
[info] 		currseg.UInfo in
[info] 		Seg {
[info] 			AInfo: currseg.AInfo,
[info] 			UInfo: uinfo,
[info] 			ConsDir: currseg.ConsDir,
[info] 			Peer: currseg.Peer,
[info] 			Past: currseg.Past,
[info] 			Future: currseg.Future,
[info] 			History: currseg.History,
[info] 		}
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires p > 0
[info] requires acc(loc, p)
[info] ensures acc(loc, p)
[info] decreases
[info] func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location, ghost p perm) Time fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires p > 0
[info] requires acc(loc, p)
[info] ensures acc(loc, p)
[info] decreases
[info] func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location, ghost p perm) Time fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Error at: <.:0:0> Assert might fail. 
[info] Expression requires 0 < p
[info] requires segs.Valid()
[info] requires MetaLen + numInf * path.InfoLen <= len(raw)
[info] requires numInf == segs.NumInfoFields()
[info] requires acc(sl.Bytes(raw[:MetaLen], 0, MetaLen), p)
[info] requires acc(sl.Bytes(InfofieldByteSlice(raw, 0), 0, path.InfoLen), p)
[info] requires 1 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 1), 0, path.InfoLen), p)
[info] requires 2 < numInf ==> acc(sl.Bytes(InfofieldByteSlice(raw, 2), 0, path.InfoLen), p)
[info] requires acc(sl.Bytes(raw[HopfieldsStartIdx(0, segs):], 0, len(raw[HopfieldsStartIdx(0, segs):])), p)
[info] ensures  acc(sl.Bytes(raw, 0, len(raw)), p)
[info] decreases
[info] func CombineBytesFromInfoFields(raw []byte, numInf int, segs io.SegLens, p perm) {
[info] 	sl.Unslice_Bytes(raw, HopfieldsStartIdx(0, segs), len(raw), p)
[info] 	if(numInf > 2) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(2, MetaLen), HopfieldsStartIdx(0, segs), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(2, MetaLen), len(raw),
[info] 			HopfieldsStartIdx(0, segs), p)
[info] 	}
[info] 	if(numInf > 1) {
[info] 		sl.Unslice_Bytes(raw, path.InfoFieldOffset(1, MetaLen),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 		sl.CombineAtIndex_Bytes(raw, path.InfoFieldOffset(1, MetaLen), len(raw),
[info] 			path.InfoFieldOffset(2, MetaLen), p)
[info] 	}
[info] 	sl.Unslice_Bytes(raw, MetaLen, path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.Unslice_Bytes(raw, 0, MetaLen, p)
[info] 	sl.CombineAtIndex_Bytes(raw, MetaLen, len(raw), path.InfoFieldOffset(1, MetaLen), p)
[info] 	sl.CombineAtIndex_Bytes(raw, 0, len(raw), MetaLen, p)
[info] } fails linter check: Input Unicity
[info] Gobra found 33 errors.
[info] Writing report to /tmp/stats.json
[info] 
[error] Nonzero exit code returned from runner: 1
[error] (Compile / run) Nonzero exit code returned from runner: 1
[error] Total time: 652 s (10:52), completed 17 Jul 2025, 16:52:24
