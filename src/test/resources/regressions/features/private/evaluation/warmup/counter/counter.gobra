// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

package counter

type Counter struct {
	count int
	called int
}

pred (c *Counter) Mem() {
	acc(&c.count) && acc(&c.called)
}

requires c.Mem()
pure func (c *Counter) C() int { 
	return unfolding c.Mem() in c.count  
}

ensures result.Mem()
ensures result.C() == 0 //initializing Counter with value 0
construct &Counter() {
	fold result.Mem()
}

requires c.Mem()
ensures c.Mem()
ensures c.C() == old(c.C()) + 1
ensures res == c.C()
private {
	requires acc(&c.count) && acc(&c.called)
	ensures acc(&c.count) && acc(&c.called)
	ensures c.count == old(c.count) + 1
	ensures c.called == old(c.called) + 1
	ensures res == c.count
	proof {
		unfold c.Mem()
		res = c.Inc()
		fold c.Mem()
	}
}
func (c *Counter) Inc() (res int) {
	c.count += 1
	c.called += 1
	return c.count
}

requires c.Mem()
ensures c.Mem()
ensures c.C() == old(c.C()) - 1
ensures res == c.C()
private {
	requires acc(&c.count) && acc(&c.called)
	ensures acc(&c.count) && acc(&c.called)
	ensures c.count == old(c.count) - 1
	ensures c.called == old(c.called) + 1
	ensures res == c.count
	proof {
		unfold c.Mem()
		res = c.Dec()
		fold c.Mem()
	}
}
func (c *Counter) Dec() (res int) {
	c.count -= 1
	c.called += 1
	return c.count
}